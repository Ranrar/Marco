/// The html_viewer.rs is a UI component that displays the HTML output generated by the backend renderer
/// It does not perform the actual Markdown-to-HTML conversion itself; instead,
/// it takes the already-rendered HTML and presents it in the UI.
use gtk4::prelude::*;
use webkit6::prelude::*;

use webkit6::WebView;
/// TODO change open link polici to onnly allow open target when klicking
/// Create a WebView widget and load the provided HTML string.
pub fn create_html_viewer(html: &str) -> WebView {
    let webview = WebView::new();
    // Defer loading HTML until the main loop is idle to ensure the widget
    // has been allocated and avoid 'trying to snapshot GtkGizmo without a current allocation' warnings.
    let html_string = html.to_string();
    let webview_clone = webview.clone();
    glib::idle_add_local(move || {
        webview_clone.load_html(&html_string, None);
        // Stop the idle source after one run
        glib::ControlFlow::Break
    });
    webview.set_vexpand(true);
    webview.set_hexpand(true);
    webview
}

/// Wraps the HTML body with a full HTML document, injecting the provided CSS string into the <head>.
pub fn wrap_html_document(body: &str, css: &str, theme_mode: &str) -> String {
    format!(
        r#"<!DOCTYPE html>
<html class="{}">
  <head>
    <meta charset=\"utf-8\">
    <style>body {{ font-family: sans-serif; }}
{}</style>
  </head>
  <body>{}</body>
</html>"#,
        theme_mode, css, body
    )
}

/// Create a scrollable, read-only viewer that displays the raw HTML source.
/// For show source code.
pub fn create_html_source_viewer(html: &str) -> gtk4::ScrolledWindow {
    use gtk4::{PolicyType, ScrolledWindow, TextBuffer, TextView};

    let sw = ScrolledWindow::new();
    sw.set_policy(PolicyType::Automatic, PolicyType::Automatic);
    sw.set_min_content_width(200);
    sw.set_min_content_height(200);

    let tv = TextView::new();
    tv.set_editable(false);
    tv.set_cursor_visible(false);
    tv.set_wrap_mode(gtk4::WrapMode::None);

    // Use a monospace style class for better readability (CSS must define .monospace)
    let ctx = tv.style_context();
    ctx.add_class("monospace");

    let buffer = TextBuffer::new(None::<&gtk4::TextTagTable>);
    buffer.set_text(html);
    tv.set_buffer(Some(&buffer));

    sw.set_child(Some(&tv));
    sw
}
