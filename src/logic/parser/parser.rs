#[cfg(test)]
mod tests {
    use crate::logic::ast::blocks_and_inlines::{Block, LeafBlock};
    use crate::logic::parser::event::Event;
    use crate::logic::parser::transform::EventPipeline;
    use crate::logic::parser::diagnostics::Diagnostics;
    use super::*;

    fn dummy_block() -> Block {
        Block::Leaf(LeafBlock::Paragraph(vec![], None))
    }

    #[test]
    fn event_iter_basic() {
        let block = dummy_block();
        let mut iter = EventIter::new(&block, None);
        let mut found = false;
        while let Some(_event) = iter.next() {
            found = true;
            break; // Only need to confirm at least one event is emitted
        }
        assert!(found, "Should emit at least one event");
    }

    #[test]
    fn event_iter_collects_diagnostics() {
        let block = dummy_block();
        let mut diagnostics = Diagnostics::new();
        let mut iter = EventIter::new(&block, Some(&mut diagnostics));
        while let Some(_event) = iter.next() {
            // Diagnostics are collected inside iterator
        }
        assert!(diagnostics.unsupported.is_empty(), "Should not collect unsupported events for dummy block");
    }

    #[test]
    fn event_iter_with_pipeline() {
        let block = dummy_block();
        let mut pipeline = EventPipeline::new();
        pipeline.add_filter(|event: &mut Event| !matches!(event, Event::Unsupported(_, _)));
        let mut iter = EventIter::with_pipeline(&block, pipeline, None);
        let mut found_unsupported = false;
        while let Some(event) = iter.next() {
            if matches!(event, Event::Unsupported(_, _)) {
                found_unsupported = true;
            }
        }
        assert!(!found_unsupported, "Pipeline should filter unsupported events");
    }
}
// Main parser: Token stream â†’ Event stream or AST (supports streaming)
use super::event::Event;
use crate::logic::ast::blocks_and_inlines::Block;
use crate::logic::parser::transform::EventPipeline;

pub struct EventIter<'a> {
    stack: Vec<&'a Block>,
    state: Vec<Event>,
    pipeline: Option<EventPipeline>,
    diagnostics: Option<&'a mut super::diagnostics::Diagnostics>,
}

impl<'a> EventIter<'a> {
    pub fn new(root: &'a Block, diagnostics: Option<&'a mut super::diagnostics::Diagnostics>) -> Self {
        Self {
            stack: vec![root],
            state: vec![],
            pipeline: None,
            diagnostics,
        }
    }
    pub fn with_pipeline(root: &'a Block, pipeline: EventPipeline, diagnostics: Option<&'a mut super::diagnostics::Diagnostics>) -> Self {
        Self {
            stack: vec![root],
            state: vec![],
            pipeline: Some(pipeline),
            diagnostics,
        }
    }
}
impl<'a> Iterator for EventIter<'a> {
    type Item = Event;
    fn next(&mut self) -> Option<Self::Item> {
        // Drain state first (for events generated by previous block)
        if let Some(mut event) = self.state.pop() {
            if let Some(diag) = &mut self.diagnostics {
                diag.collect(&event);
            }
            if let Some(pipeline) = &mut self.pipeline {
                if pipeline.process(&mut event) {
                    return Some(event);
                } else {
                    return self.next();
                }
            } else {
                return Some(event);
            }
        }
        // Traverse AST stack
        while let Some(block) = self.stack.pop() {
            match block {
                Block::Container(container) => {
                    match container {
                        crate::logic::ast::blocks_and_inlines::ContainerBlock::Document(children, _) |
                        crate::logic::ast::blocks_and_inlines::ContainerBlock::BlockQuote(children, _) => {
                            for child in children.iter().rev() {
                                self.stack.push(child);
                            }
                            // Use GroupType::List for all containers (simplified)
                            self.state.push(Event::GroupStart(
                                crate::logic::parser::event::GroupType::List,
                                None,
                                None,
                            ));
                            self.state.push(Event::GroupEnd(
                                crate::logic::parser::event::GroupType::List,
                                None,
                                None,
                            ));
                        }
                        crate::logic::ast::blocks_and_inlines::ContainerBlock::ListItem { contents, .. } => {
                            for child in contents.iter().rev() {
                                self.stack.push(child);
                            }
                            self.state.push(Event::GroupStart(
                                crate::logic::parser::event::GroupType::List,
                                None,
                                None,
                            ));
                            self.state.push(Event::GroupEnd(
                                crate::logic::parser::event::GroupType::List,
                                None,
                                None,
                            ));
                        }
                        crate::logic::ast::blocks_and_inlines::ContainerBlock::List { items, .. } => {
                            for item in items.iter().rev() {
                                self.stack.push(item);
                            }
                            self.state.push(Event::GroupStart(
                                crate::logic::parser::event::GroupType::List,
                                None,
                                None,
                            ));
                            self.state.push(Event::GroupEnd(
                                crate::logic::parser::event::GroupType::List,
                                None,
                                None,
                            ));
                        }
                    }
                }
                Block::Leaf(leaf) => {
                    use crate::logic::ast::blocks_and_inlines::LeafBlock;
                    use crate::logic::parser::event::{Tag, TagEnd};
                    match leaf {
                        LeafBlock::Paragraph(_, attrs) => {
                            self.state.push(Event::End(TagEnd::Paragraph(attrs.clone()), None, attrs.clone()));
                            self.state.push(Event::Start(Tag::Paragraph(attrs.clone()), None, attrs.clone()));
                        }
                        LeafBlock::Heading { level, attributes, .. } => {
                            self.state.push(Event::End(TagEnd::Heading(attributes.clone()), None, attributes.clone()));
                            self.state.push(Event::Start(Tag::Heading(*level, attributes.clone()), None, attributes.clone()));
                        }
                        LeafBlock::AtxHeading { level, attributes, .. } => {
                            self.state.push(Event::End(TagEnd::Heading(attributes.clone()), None, attributes.clone()));
                            self.state.push(Event::Start(Tag::Heading(*level, attributes.clone()), None, attributes.clone()));
                        }
                        LeafBlock::SetextHeading { level, attributes, .. } => {
                            self.state.push(Event::End(TagEnd::Heading(attributes.clone()), None, attributes.clone()));
                            self.state.push(Event::Start(Tag::Heading(*level, attributes.clone()), None, attributes.clone()));
                        }
                        LeafBlock::IndentedCodeBlock { attributes, .. } => {
                            self.state.push(Event::End(TagEnd::CodeBlock(attributes.clone()), None, attributes.clone()));
                            self.state.push(Event::Start(Tag::CodeBlock(attributes.clone()), None, attributes.clone()));
                        }
                        LeafBlock::FencedCodeBlock { attributes, .. } => {
                            self.state.push(Event::End(TagEnd::CodeBlock(attributes.clone()), None, attributes.clone()));
                            self.state.push(Event::Start(Tag::CodeBlock(attributes.clone()), None, attributes.clone()));
                        }
                        LeafBlock::ThematicBreak { attributes, .. } => {
                            self.state.push(Event::End(TagEnd::HtmlBlock(attributes.clone()), None, attributes.clone()));
                            self.state.push(Event::Start(Tag::HtmlBlock(attributes.clone()), None, attributes.clone()));
                        }
                        LeafBlock::HtmlBlock { attributes, .. } => {
                            self.state.push(Event::End(TagEnd::HtmlBlock(attributes.clone()), None, attributes.clone()));
                            self.state.push(Event::Start(Tag::HtmlBlock(attributes.clone()), None, attributes.clone()));
                        }
                        LeafBlock::LinkReferenceDefinition { attributes, .. } => {
                            self.state.push(Event::End(TagEnd::HtmlBlock(attributes.clone()), None, attributes.clone()));
                            self.state.push(Event::Start(Tag::HtmlBlock(attributes.clone()), None, attributes.clone()));
                        }
                        LeafBlock::BlankLine => {
                            // No event for blank line
                        }
                        LeafBlock::Math(math_block) => {
                            self.state.push(Event::MathBlock {
                                content: math_block.content.clone(),
                                math_type: Some(math_block.math_type.clone()),
                                pos: None,
                                attributes: math_block.attributes.clone(),
                            });
                        }
                    }
                }
            }
            // After pushing new events, try to emit one
            return self.next();
        }
        None
    }
}
