/// The html_viewer.rs is a UI component that displays the HTML output generated by the backend renderer
/// It does not perform the actual Markdown-to-HTML conversion itself; instead,
/// it takes the already-rendered HTML and presents it in the UI.
use gtk4::prelude::*;
use std::path::Path;
use webkit6::prelude::*;
use webkit6::WebView;
/// TODO change open link polici to onnly allow open target when klicking

/// Generate a file:// base URI from a document path for resolving relative file references.
/// If the document has a parent directory, returns a file:// URI for that directory.
/// This allows relative image paths and other file references in the document to work correctly.
pub fn generate_base_uri_from_path<P: AsRef<Path>>(document_path: P) -> Option<String> {
    if let Some(parent_dir) = document_path.as_ref().parent() {
        // Convert parent directory to absolute path and create file:// URI
        if let Ok(absolute_parent) = parent_dir.canonicalize() {
            let path_str = absolute_parent.to_string_lossy();
            Some(format!("file://{}/", path_str))
        } else {
            // Fallback: use the path as-is if canonicalize fails
            let path_str = parent_dir.to_string_lossy();
            Some(format!("file://{}/", path_str))
        }
    } else {
        None
    }
}
/// Setup UserContentManager for proper script and stylesheet management
/// This prevents memory leaks from accumulated JavaScript and CSS
fn setup_user_content_manager(webview: &WebView) {
    // Store a reference to track if cleanup is needed
    // For now, we'll implement the cleanup pattern in the HTML template
    // and use proper JavaScript management through the template system
    log::debug!("[webkit6] Setting up UserContentManager for WebView: {:p}", webview);
}

/// Create a WebView widget and load the provided HTML string.
/// If base_uri is provided, it will be used as the base for resolving relative paths.
pub fn create_html_viewer(html: &str) -> WebView {
    create_html_viewer_with_base(html, None)
}

/// Create a WebView widget with an optional base URI for resolving relative paths.
/// This version allows specifying a base URI to resolve local file references.
pub fn create_html_viewer_with_base(html: &str, base_uri: Option<&str>) -> WebView {
    let webview = WebView::new();

    // Configure WebKit security settings to allow local file access
    if let Some(settings) = webkit6::prelude::WebViewExt::settings(&webview) {
        settings.set_allow_file_access_from_file_urls(true);
        settings.set_allow_universal_access_from_file_urls(true);
        settings.set_auto_load_images(true);
    }

    // Initialize UserContentManager for proper script and stylesheet management
    setup_user_content_manager(&webview);

    // Set up cleanup on destruction to prevent memory leaks
    webview.connect_destroy({
        let webview_cleanup = webview.clone();
        move |_| {
            // Cleanup JavaScript state before destruction
            webview_cleanup.evaluate_javascript(
                "(function() { 
                    if (window.MarcoPreview) { 
                        MarcoPreview.cleanup(); 
                        delete window.MarcoPreview; 
                    } 
                })()",
                None,                      // world_name
                None,                      // source_uri
                None::<&gio::Cancellable>, // cancellable
                |_| {
                    // Cleanup completed, WebView can be safely destroyed
                },
            );
        }
    });

    // Defer loading HTML until the main loop is idle to ensure the widget
    // has been allocated and avoid 'trying to snapshot GtkGizmo without a current allocation' warnings.
    let html_string = html.to_string();
    let base_uri_string = base_uri.map(|s| s.to_string());
    let webview_clone = webview.clone();
    glib::idle_add_local(move || {
        webview_clone.load_html(&html_string, base_uri_string.as_deref());
        // Stop the idle source after one run
        glib::ControlFlow::Break
    });
    webview.set_vexpand(true);
    webview.set_hexpand(true);
    webview
}

/// Update the content in an existing WebView using JavaScript injection.
/// This avoids full page reloads and provides smooth updates while preserving scroll position.
/// Enhanced to prevent memory leaks by using a more efficient approach.
pub fn update_html_content_smooth(webview: &WebView, content: &str) {
    let escaped_content = content
        .replace('\\', "\\\\")
        .replace('\'', "\\'")
        .replace('\n', "\\n")
        .replace('\r', "\\r");

    // Use a more efficient JavaScript approach that avoids creating multiple functions
    // and cleans up properly to prevent memory leaks
    let js_code = format!(
        r#"
        (function() {{
            try {{
                // Cleanup any previous temporary variables
                if (window._marcoTempUpdate) {{
                    delete window._marcoTempUpdate;
                }}
                
                // Check if our standard update function exists
                if (typeof updateContent === 'function') {{
                    updateContent('{}');
                    return;
                }}
                
                // Fallback: direct DOM update without creating persistent variables
                var container = document.getElementById('marco-content-container');
                if (container) {{
                    // Save scroll position
                    var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                    
                    // Update content
                    container.innerHTML = '{}';
                    
                    // Restore scroll position
                    setTimeout(function() {{
                        document.documentElement.scrollTop = scrollTop;
                        document.body.scrollTop = scrollTop;
                    }}, 10);
                }} else {{
                    // Last resort: create container
                    var body = document.body || document.getElementsByTagName('body')[0];
                    if (body) {{
                        body.innerHTML = '<div id="marco-content-container">{}</div>';
                    }}
                }}
            }} catch(e) {{
                console.error('Error in content update:', e);
            }}
        }})();
        "#,
        escaped_content, escaped_content, escaped_content
    );

    let webview_clone = webview.clone();

    glib::idle_add_local(move || {
        webview_clone.evaluate_javascript(
            &js_code,
            None,                      // world_name
            None,                      // source_uri
            None::<&gio::Cancellable>, // cancellable
            |result| match result {
                Ok(_) => log::debug!("[webkit6] Content update JavaScript executed successfully"),
                Err(e) => log::warn!(
                    "[webkit6] Failed to execute content update JavaScript: {}",
                    e
                ),
            },
        );
        glib::ControlFlow::Break
    });
}

/// Wraps the HTML body with a full HTML document, injecting the provided CSS string into the <head>.
/// Enhanced with proper cleanup mechanisms to prevent memory leaks.
pub fn wrap_html_document(body: &str, css: &str, theme_mode: &str) -> String {
    // Include a named <style> element and small JS helpers so the host can
    // update CSS and theme class without reloading the whole document.
    // Enhanced with cleanup mechanisms to prevent memory accumulation.
    let doc = format!(
        r#"<!DOCTYPE html>
<html class="{}">
    <head>
        <meta charset=\"utf-8\">
        <style id=\"marco-preview-style\">body {{ font-family: sans-serif; }}
{}</style>
        <script>
            // Marco Preview Management Object - prevents global namespace pollution
            window.MarcoPreview = (function() {{
                var scrollTimeouts = [];
                
                // Cleanup function to clear any pending timeouts
                function cleanup() {{
                    scrollTimeouts.forEach(function(id) {{
                        clearTimeout(id);
                    }});
                    scrollTimeouts = [];
                }}
                
                return {{
                    setCSS: function(css) {{
                        try {{
                            var el = document.getElementById('marco-preview-style');
                            if (el) {{
                                el.innerHTML = css;
                            }}
                        }} catch(e) {{
                            console.error('Error setting CSS:', e);
                        }}
                    }},
                    
                    setTheme: function(mode) {{
                        try {{
                            document.documentElement.className = mode;
                        }} catch(e) {{
                            console.error('Error setting theme:', e);
                        }}
                    }},
                    
                    updateContent: function(htmlContent) {{
                        try {{
                            // Clean up any pending scroll restoration
                            cleanup();
                            
                            // Save current scroll position
                            var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;
                            
                            // Update content container
                            var container = document.getElementById('marco-content-container');
                            if (container) {{
                                container.innerHTML = htmlContent;
                                
                                // Restore scroll position after a brief delay
                                var timeoutId = setTimeout(function() {{
                                    document.documentElement.scrollTop = scrollTop;
                                    document.body.scrollTop = scrollTop;
                                    // Remove this timeout from tracking
                                    var index = scrollTimeouts.indexOf(timeoutId);
                                    if (index > -1) {{
                                        scrollTimeouts.splice(index, 1);
                                    }}
                                }}, 10);
                                scrollTimeouts.push(timeoutId);
                            }}
                        }} catch(e) {{
                            console.error('Error updating content:', e);
                        }}
                    }},
                    
                    setContent: function(htmlContent) {{
                        try {{
                            var container = document.getElementById('marco-content-container');
                            if (container) {{
                                container.innerHTML = htmlContent;
                            }}
                        }} catch(e) {{
                            console.error('Error setting content:', e);
                        }}
                    }},
                    
                    cleanup: cleanup
                }};
            }})();
            
            // Legacy function aliases for backwards compatibility
            function setPreviewCSS(css) {{ MarcoPreview.setCSS(css); }}
            function setPreviewTheme(mode) {{ MarcoPreview.setTheme(mode); }}
            function updateContent(htmlContent) {{ MarcoPreview.updateContent(htmlContent); }}
            function setContent(htmlContent) {{ MarcoPreview.setContent(htmlContent); }}
            
            // Cleanup on page unload
            window.addEventListener('beforeunload', function() {{
                if (window.MarcoPreview) {{
                    MarcoPreview.cleanup();
                }}
            }});
        </script>
    </head>
    <body>
        <div id="marco-content-container">{}</div>
    </body>
</html>"#,
        theme_mode, css, body
    );
    doc
}

// Note: in-page JS helpers are embedded in the HTML template produced by
// `wrap_html_document`. To avoid binding issues across webkit6 versions we
// intentionally don't call JS from Rust here. If/when needed, add a small
// compatibility wrapper that uses the correct webkit6 API available in the
// project's environment.

/// Create a scrollable, read-only viewer that displays the raw HTML source.
/// For show source code.
/// Create a scrollable, read-only viewer that displays the raw HTML source.
/// If `editor_bg`/`editor_fg` are provided, apply those colors to the TextView so
/// the source view matches the editor theme. If `add_editor_scrolled_class` is
/// true, the ScrolledWindow will be given the `editor-scrolled` CSS class so
/// any global scrollbar styling injected by the application applies to it.
pub fn create_html_source_viewer(
    html: &str,
    editor_bg: Option<&str>,
    editor_fg: Option<&str>,
    add_editor_scrolled_class: bool,
) -> gtk4::ScrolledWindow {
    use gtk4::{PolicyType, ScrolledWindow, TextBuffer, TextView};

    let sw = ScrolledWindow::new();
    sw.set_policy(PolicyType::Automatic, PolicyType::Automatic);
    sw.set_min_content_width(200);
    sw.set_min_content_height(200);

    let tv = TextView::new();
    tv.set_editable(false);
    tv.set_cursor_visible(false);
    tv.set_wrap_mode(gtk4::WrapMode::None);

    // Use a monospace style class for better readability (CSS must define .monospace)
    let ctx = tv.style_context();
    ctx.add_class("monospace");

    // If editor colors are provided, add a wrapper class and load a small
    // CSS provider to set the TextView foreground/background so the source
    // viewer visually matches the editor theme.
    if editor_bg.is_some() || editor_fg.is_some() {
        // Add a class to the scrolled window so the CSS can target the child
        sw.add_css_class("source-preview");
        if let Some(display) = gtk4::gdk::Display::default() {
            let mut css_rules = String::new();
            let bg = editor_bg.unwrap_or("transparent");
            let fg = editor_fg.unwrap_or("#000000");
            // Target the monospace class we set on the TextView
            css_rules.push_str(&format!(
                ".source-preview .monospace {{ background-color: {}; color: {}; }}",
                bg, fg
            ));
            let provider = gtk4::CssProvider::new();
            provider.load_from_data(&css_rules);
            // Register CSS provider for the display so our small rules apply.
            gtk4::style_context_add_provider_for_display(
                &display,
                &provider,
                gtk4::STYLE_PROVIDER_PRIORITY_APPLICATION,
            );
        }
    }

    let buffer = TextBuffer::new(None::<&gtk4::TextTagTable>);
    buffer.set_text(html);
    tv.set_buffer(Some(&buffer));
    sw.set_child(Some(&tv));

    // If requested, add the editor-scrolled CSS class so the app's scrollbar
    // CSS (which uses the .editor-scrolled selector) applies to this scrolled window.
    if add_editor_scrolled_class {
        sw.add_css_class("editor-scrolled");
    }
    sw
}
