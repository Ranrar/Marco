// Marco flavor grammar
// This file defines the Marco markdown dialect used by the editor and parser.
// Covered features: link handling (validation, YouTube embedding, image.
// list parsing (ordered, unordered, nested, task lists), macros (inline and block),
// tables, headings, paragraphs, code/maths blocks, and common inline formatting.

// ===== WHITESPACE AND INDENTATION =====
// WHITESPACE is special in Pest - it gets consumed automatically between tokens
// For indented code, we need to handle spaces explicitly with atomic rules
WHITESPACE = _{ " " | "\t" }
NEWLINE    = _{ "\r\n" | "\n" }
INDENT_OPT = _{ (" " | "\t")* }
BLANK_LINE = _{ (" " | "\t")* ~ NEWLINE }
INDENT_SPACES = @{ " " ~ " " ~ " " ~ " " }  // Exactly 4 spaces as atomic rule
INDENT_TAB = @{ "\t" }
INDENT_UNIT = _{ INDENT_SPACES | INDENT_TAB }  // One unit of indentation
NON_INDENT = _{ " "{0, 3} }

// ===== CASE-INSENSITIVE KEYWORDS =====
KW_NOTE     = @{ ^"note" }
KW_TIP      = @{ ^"tip" }
KW_WARNING  = @{ ^"warning" }
KW_DANGER   = @{ ^"danger" }
KW_INFO     = @{ ^"info" }
KW_BOOKMARK = @{ ^"bookmark" }
KW_PAGE     = @{ ^"page" }
KW_DOC      = @{ ^"doc" }
KW_TOC      = @{ ^"toc" }
KW_TAB      = @{ ^"tab" }

// Script types
KW_BASH       = @{ ^"bash" }
KW_ZSH        = @{ ^"zsh" }
KW_SH         = @{ ^"sh" }
KW_BAT        = @{ ^"bat" }
KW_POWERSHELL = @{ ^"powershell" }
KW_PS         = @{ ^"ps" }
KW_PYTHON     = @{ ^"python" }
KW_PY         = @{ ^"py" }
KW_RUN        = @{ ^"run@" }

// Diagram types
KW_MERMAID  = @{ ^"mermaid" }
KW_GRAPHVIZ = @{ ^"graphviz" }

// ===== MAIN STRUCTURE =====  
document =  { section* }
section  = _{ BLANK_LINE* ~ block ~ BLANK_LINE* }

// ===== BLOCK LEVEL - Ordered by specificity =====
block = { code_block | math_block | hr | heading | blockquote | table | list | macro_block | footnote_def | reference_definition | reference_link | reference_image | def_list | block_comment | block_html | paragraph | unknown_block }

// Error recovery for unrecognized blocks
unknown_block = { (!NEWLINE ~ ANY)+ }
macro_block   = { admonition_block | run_block_fenced | diagram_fenced | bookmark | block_youtube | block_image | tab_block }

// ===== INLINE LEVEL - Ordered by specificity =====
inline_core = { escaped_char | inline_link | inline_image | autolink | inline_footnote_ref | code_inline | math_inline | emphasis | strikethrough | highlight | superscript | subscript | emoji | inline_html | inline_comment | footnote_ref | macro_inline | hard_line_break | soft_line_break | text }

// Escape sequences for markdown special characters
escaped_char = @{ "\\" ~ (markdown_special | "\\") }

// Line breaks with distinction between hard and soft
hard_line_break = @{ (" "{2,} | "\\") ~ NEWLINE }
soft_line_break = @{ NEWLINE ~ &(!block_start ~ !EOI) }

inline       =  { inline_core | inline_task_item }
macro_inline =  { user_mention | run_inline | page_tag | toc | doc_ref }

// Combined emphasis rules for proper precedence
emphasis = { bold_italic | bold | italic }

// ===== TEXT AND CHARACTERS =====

word           = @{ unicode_letter+ ~ (inner_char* ~ unicode_letter+)* }
inner_char     = _{ "-" | "'" }
unicode_letter = _{ ASCII_ALPHANUMERIC | LETTER }

safe_punct       = @{ !(markdown_special) ~ PUNCTUATION }
markdown_special = _{ "*" | "_" | "`" | "#" | "[" | "]" | "~" | ">" | "|" | "$" | "@" | "^" | "=" | "-" | "\\" }

math_symbol = @{ "±" | "√" | "∞" | "∑" | "≈" | "≠" | "≤" | "≥" | "∆" | "π" | "α" | "β" | "γ" | "λ" | "μ" | "σ" | "Ω" | "+" | "=" | "×" | "÷" }

// Phase 1d: Line-aware text rule with sophisticated boundary detection
// Conservative text: refuse to match if the line begins with any block-start marker
// Text must be conservative at the start of a line (avoid stealing blocks),
// but mid-line text should be permissive. Use an explicit negative lookahead for
// common block-start sequences to avoid false positives (heading, hr, list,
// blockquote, admonition, code fence, table, HTML).
text = {
    // More permissive text rule: Only refuse block markers that have proper syntax.
    // Allow content that starts with formatting markers (* _ ` etc.) since these
    // should be handled by formatting rules or serve as fallback content.
    (WHITESPACE+ ~ &(NEWLINE | EOI))
  | NEWLINE+  // Special case: just newlines
  | // Special case: whitespace-only lines
  ((SOI | NEWLINE) ~ WHITESPACE* ~ !(("#"{1, 6} ~ " ") | // ATX heading (must have space after #)
  ("***" | "---" | "___") ~ (WHITESPACE | NEWLINE | EOI) | // horizontal rule
  ">" ~ (" " | "\t" | &NEWLINE | &EOI) | // blockquote - enhanced detection
  ":::" | // admonition
  "```" ~ (WHITESPACE | NEWLINE | ASCII_ALPHA) | // fenced code block (must have space, newline, or language)
  INDENT_UNIT | // indented code
  (ASCII_DIGIT+ ~ "." ~ " ") | // ordered list
  (("-" | "*" | "+") ~ " ") | // unordered list (note: single * without space is not a list)
  "|" | // table row
  ("<" ~ ASCII_ALPHA ~ ASCII_ALPHANUMERIC* ~ (WHITESPACE | ">")) // html block tags (not inline tags)
  ) ~ text_no_formatting+)
  | start_line_formatting // Handle line-start formatting chars as text fallback

  | text_no_formatting+
}

// Handle formatting characters at line start that should be treated as text
start_line_formatting = @{
    (SOI | NEWLINE) ~ WHITESPACE* ~ formatting_char ~ text_content_chars*
}

// Characters that can start formatting but might be literal text
formatting_char = { "*" | "_" | "`" | "~" | "=" | "^" | "#" | "!" | "$" }

// Non-silent version of text content for atomic rules
text_content_chars = {
    word
  | safe_punct
  | !((" "{2,} | "\\") ~ NEWLINE) ~ (" " | "\t") // Single space or tab, but not hard line break pattern
  | math_symbol
  | inline_formatting_safe
  | ("`" ~ !"`")
  | "*"
  | "_"
  | "="
  | "^"
  | "#"
  | "!"
  | "$"
}

// More restrictive text content that stops at formatting boundaries
text_no_formatting = _{
    !("`" ~ (!"`" ~ ANY)+ ~ "`") ~ // Don't match across inline code
    !(("**" | "__") ~ (!"**" ~ !"__" ~ ANY)+ ~ ("**" | "__")) ~ // Don't match across bold
    !("*" ~ (!"*" ~ ANY)+ ~ "*") ~ // Don't match across italic (but allow double asterisk)
    !("$" ~ (!"$" ~ ANY)+ ~ "$") ~ // Don't match across inline math
    !((" "{2,} | "\\") ~ NEWLINE) ~ // Don't match hard line breaks
    !NEWLINE ~ // Don't match soft line breaks
    (word | safe_punct | " " | "\t" | math_symbol | inline_formatting_safe)
}

// Detect block starts when anchored to start of input/line
// Detect block starts when anchored to start of input/line. Allow optional leading whitespace.
// Block markers (used in negative lookaheads after optional whitespace has been consumed)
line_start_marker = _{
    (heading_start | hr_start | list_start | blockquote_start | admonition_start | code_start | table_start | html_start)
}

heading_start = _{ "#"{1, 6} ~ " " }
hr_start      = _{ ("***" | "---" | "___") ~ (WHITESPACE | NEWLINE | EOI) }
// List start must be marker followed by space and not part of a word (e.g. #1. not a list)
list_start = _{
    NON_INDENT? ~ (("-" | "*" | "+") ~ " " | (ASCII_DIGIT+ ~ "." ~ " "))
}
// Enhanced blockquote detection - matches > with optional trailing space/tab or at line end
blockquote_start = _{ ">" ~ (" " | "\t" | &NEWLINE | &EOI) }
admonition_start = _{ ":::" }
code_start       = _{ "```" | INDENT_UNIT }
// HTML start detection to prevent text consuming tags that begin a block
html_start  = _{ "<" ~ ASCII_ALPHA }
table_start = _{ "|" }

inline_formatting_safe = _{
    !("**" | "__" | "*" | "_" | "```" | "!" | "$$" | "$" | "~" | "\\" | "|") ~ ANY
}

// URL components
URL_SAFE = _{ unicode_letter | ASCII_DIGIT | "-" | "_" | "." | "/" | "?" | "&" | "=" | "%" | "#" | "~" | ":" }

// ===== PARAGRAPH =====
paragraph_line = { inline_no_newline+ }
inline_no_newline = { escaped_char | inline_link | inline_image | autolink | inline_footnote_ref | code_inline | math_inline | emphasis | strikethrough | highlight | superscript | subscript | emoji | inline_html | inline_comment | footnote_ref | macro_inline | hard_line_break | text_no_newline }
text_no_newline = { 
    // Allow whitespace but not newlines, and stop at block markers at line start
    (WHITESPACE+ ~ &(NEWLINE | EOI))
  | // Handle line-start with negative lookahead for block markers  
  ((SOI | NEWLINE) ~ WHITESPACE* ~ !(("#"{1, 6} ~ " ") | // ATX heading
    ("***" | "---" | "___") ~ (WHITESPACE | NEWLINE | EOI) | // horizontal rule
    ">" ~ (" " | "\t" | &NEWLINE | &EOI) | // blockquote
    ":::" | // admonition
    "```" ~ (WHITESPACE | NEWLINE | ASCII_ALPHA) | // fenced code
    INDENT_UNIT | // indented code
    (ASCII_DIGIT+ ~ "." ~ " ") | // ordered list
    (("-" | "*" | "+") ~ " ") | // unordered list
    "|" | // table row
    ("<" ~ ASCII_ALPHA ~ ASCII_ALPHANUMERIC* ~ (WHITESPACE | ">")) // html block tags
  ) ~ text_no_formatting+)
  | start_line_formatting // Handle line-start formatting chars as text fallback
  | text_no_formatting+
}
paragraph = { 
    NON_INDENT? ~ !(line_start_marker) ~ paragraph_line ~ 
    (NEWLINE ~ !NEWLINE ~ !(WHITESPACE* ~ line_start_marker) ~ paragraph_line)* 
}

// Helper to identify block starts
// More precise block start detection anchored at line start with comprehensive coverage
block_start = _{
    (SOI | NEWLINE) ~ WHITESPACE* ~ line_start_marker
}

// ===== HEADINGS =====
// ATX headings (##) and Setext headings (underlines)
// Allow 0-3 spaces of indentation before heading markers (CommonMark spec)
// ATX headings end at the end of the line
H1 = { NON_INDENT? ~ "#" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H2 = { NON_INDENT? ~ "##" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H3 = { NON_INDENT? ~ "###" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H4 = { NON_INDENT? ~ "####" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H5 = { NON_INDENT? ~ "#####" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H6 = { NON_INDENT? ~ "######" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }

// Setext headings: CommonMark compliant - underline must be on its own line
setext_h1 = { NON_INDENT? ~ setext_content ~ NEWLINE ~ NON_INDENT? ~ "="+ ~ (WHITESPACE* ~ (NEWLINE | EOI)) }
setext_h2 = { NON_INDENT? ~ setext_content ~ NEWLINE ~ NON_INDENT? ~ "-"+ ~ (WHITESPACE* ~ (NEWLINE | EOI)) }

// Setext content: any characters except newline (will be processed as inline later)
setext_content = { (!NEWLINE ~ ANY)+ }

// Heading content: inline content until end of line (no newlines within heading content)
heading_content = { heading_text+ }
heading_text = { !(NEWLINE | EOI) ~ inline_core }
heading         = { H6 | H5 | H4 | H3 | H2 | H1 | setext_h2 | setext_h1 }

// ===== BLOCKQUOTE =====
blockquote_line = { ">" ~ " "? ~ inline* }
blockquote      = { blockquote_line ~ (NEWLINE ~ blockquote_line)* }

// ===== TEXT FORMATTING =====
// Bold: **text** or __text__ with error recovery for unclosed
bold_asterisk   = @{ "**" ~ (!"**" ~ (!NEWLINE ~ ANY))+ ~ ("**" | &(NEWLINE | EOI)) }
bold_underscore = @{ "__" ~ (!"__" ~ (!NEWLINE ~ ANY))+ ~ ("__" | &(NEWLINE | EOI)) }
bold            =  { bold_asterisk | bold_underscore }

// Italic: *text* or _text_ with error recovery for unclosed
// Improved to handle single markers better and avoid conflicts with bold
italic_asterisk   = @{ "*" ~ !"*" ~ (!"*" ~ (!NEWLINE ~ ANY))+ ~ ("*" | &(NEWLINE | EOI)) }
italic_underscore = @{ "_" ~ !"_" ~ (!"_" ~ (!NEWLINE ~ ANY))+ ~ ("_" | &(NEWLINE | EOI)) }
italic            =  { italic_asterisk | italic_underscore }

// Bold + Italic combinations
bold_italic_triple_asterisk   = @{ "***" ~ (!"***" ~ (!NEWLINE ~ ANY))+ ~ "***" }
bold_italic_triple_underscore = @{ "___" ~ (!"___" ~ (!NEWLINE ~ ANY))+ ~ "___" }
bold_italic_mixed_ast_under   = @{ "**_" ~ (!"_**" ~ (!NEWLINE ~ ANY))+ ~ "_**" }
bold_italic_mixed_under_ast   = @{ "__*" ~ (!"*__" ~ (!NEWLINE ~ ANY))+ ~ "*__" }
bold_italic_triple_mixed_au   = @{ "***" ~ (!"___" ~ (!NEWLINE ~ ANY))+ ~ "___" }
bold_italic_triple_mixed_ua   = @{ "___" ~ (!"***" ~ (!NEWLINE ~ ANY))+ ~ "***" }
bold_italic                   =  { bold_italic_triple_asterisk | bold_italic_triple_underscore | bold_italic_mixed_ast_under | bold_italic_mixed_under_ast | bold_italic_triple_mixed_au | bold_italic_triple_mixed_ua }

// Strikethrough: ~~text~~ or --text--
strikethrough_tilde = @{ "~~" ~ (!"~~" ~ (!NEWLINE ~ ANY))+ ~ "~~" }
strikethrough_dash  = @{ "--" ~ (!"--" ~ (!NEWLINE ~ ANY))+ ~ "--" }
strikethrough       =  { strikethrough_tilde | strikethrough_dash }

// Highlight (Marco extension)
highlight = @{ "==" ~ (!"==" ~ (!NEWLINE ~ ANY))+ ~ "==" }

// Inline formatting
emoji       = @{ ":" ~ (!(":" | WHITESPACE | NEWLINE) ~ ANY)+ ~ ":" }
code_inline = @{ "`" ~ (!"`" ~ ANY)+ ~ "`" }
superscript = @{ "^" ~ (!"^" ~ (!WHITESPACE ~ ANY))+ ~ "^" }
// Support both ˅ and ~ for subscript (Marco and Pandoc styles)
// Ensure ~ doesn't conflict with ~~ (strikethrough)
subscript_arrow = @{ "˅" ~ (!"˅" ~ (!WHITESPACE ~ ANY))+ ~ "˅" }
subscript_tilde = @{ "~" ~ !"~" ~ (!"~" ~ (!WHITESPACE ~ ANY))+ ~ "~" }
subscript       =  { subscript_arrow | subscript_tilde }

// ===== LINKS AND IMAGES =====
// HTTP / HTTPS / WWW / Mailto / Local paths
http_url = @{ (("https://" | "http://") ~ URL_SAFE+) | ("www." ~ URL_SAFE+) }
www_url  = @{ "www." ~ URL_SAFE+ }

// Email - Working pattern with subdomain support
EMAIL_LOCAL       = @{ ASCII_ALPHANUMERIC+ ~ (ASCII_ALPHANUMERIC | "." | "_" | "-" | "+")* }
EMAIL_FULL_DOMAIN = @{ (ASCII_ALPHANUMERIC+ ~ ".")+ ~ ASCII_ALPHANUMERIC+ }
mailto            = @{ "mailto:" ~ EMAIL_LOCAL ~ "@" ~ EMAIL_FULL_DOMAIN }

// Local paths - More restrictive to avoid matching regular words
local_path = @{
    ("./" | "../" | "/" | ASCII_ALPHA ~ ":/" | ASCII_ALPHA ~ ":\\") ~ (!")" ~ ANY)+
  | ASCII_ALPHANUMERIC+ ~ ("/" ~ (ASCII_ALPHANUMERIC | unicode_letter | "." | "-" | "_")+)+
}

// YouTube URLs
youtube_url = @{ ("https://youtu.be/" | "http://youtu.be/" | "https://www.youtube.com/watch?v=" | "http://www.youtube.com/watch?v=") ~ URL_SAFE+ }

// Image file extensions (case-insensitive)
image_ext = @{ "." ~ (^"jpg" | ^"jpeg" | ^"png" | ^"gif" | ^"webp" | ^"svg") }
image_url = @{ (http_url | www_url | local_path) ~ image_ext }

// Inline link components - more permissive URL matching
// Link URL parsing - common for all link types
link_url = @{
    http_url
  | www_url
  | mailto
  | local_path
  | // Conservative fallback - stop at spaces, quotes, and closing parens
  (ASCII_ALPHANUMERIC | unicode_letter | "-" | "_" | "." | "/" | "?" | "&" | "=" | "%" | "#" | "~" | ":")+
}

// Link components
inline_link_text = @{ (escaped_bracket | balanced_brackets | (!"](" ~ !"]" ~ ANY))* }
escaped_bracket = { "\\" ~ ("[" | "]") }
balanced_brackets = { "[" ~ (escaped_bracket | (!"]" ~ !"[" ~ ANY))* ~ "]" }
link_title       =  { "\"" ~ (!"\"" ~ ANY)* ~ "\"" | "'" ~ (!"'" ~ ANY)* ~ "'" }

// Bracket links - explicit and clear
bracket_link_with_title    = @{ "[" ~ inline_link_text ~ "](" ~ link_url ~ WHITESPACE+ ~ link_title ~ ")" }
bracket_link_without_title = @{ "[" ~ inline_link_text ~ "](" ~ link_url ~ ")" }

// Autolinks - separate and focused
autolink_email = { "<" ~ EMAIL_LOCAL ~ "@" ~ EMAIL_FULL_DOMAIN ~ ">" }
autolink_url   = { "<" ~ link_url ~ ">" }
autolink       = { autolink_email | autolink_url }

// Main link rule - order matters: more specific first
inline_link  = { bracket_link_with_title | bracket_link_without_title | autolink }
inline_image = { "!" ~ "[" ~ inline_link_text ~ "](" ~ link_url ~ (WHITESPACE+ ~ link_title)? ~ ")" }

// Reference-style links
block_caption   = { (!"]" ~ ANY)+ }
reference_link  = { "[" ~ block_caption ~ "]" ~ "[" ~ block_caption ~ "]" }
reference_image = { "!" ~ "[" ~ block_caption ~ "]" ~ "[" ~ block_caption ~ "]" }

// Reference definition
ref_title            = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" | "'" ~ (!"'" ~ ANY)* ~ "'" }
reference_definition = { "[" ~ block_caption ~ "]" ~ ":" ~ WHITESPACE* ~ inline_link ~ (WHITESPACE+ ~ ref_title)? ~ (NEWLINE | EOI) }

// Block-level images and YouTube embeds
block_image   = { "!"? ~ "[" ~ block_caption ~ "](" ~ image_url ~ ")" }
block_youtube = { "[" ~ block_caption ~ "](" ~ youtube_url ~ ")" }

// ===== CODE =====
// Fenced code block with optional language - improved with error recovery
language_id     = @{ ASCII_ALPHA+ ~ (ASCII_ALPHANUMERIC | "-" | "_")* }
fenced_code_open = { "```" ~ language_id? ~ (NEWLINE | EOI) }
fenced_code_close = { "```" }
fenced_code_content = { (!fenced_code_close ~ ANY)* }
fenced_code     = { fenced_code_open ~ fenced_code_content ~ (fenced_code_close | &EOI) }
indented_code = @{ INDENT_UNIT+ ~ (!NEWLINE ~ ANY)+ ~ (NEWLINE ~ INDENT_UNIT+ ~ (!NEWLINE ~ ANY)+)* }
code_block      = { fenced_code | indented_code }

// ===== MATH =====
math_inline = { "$" ~ (!"$" ~ ANY | "\\" ~ "$")* ~ "$" }
math_block  = { "$$" ~ (!"$$" ~ ANY | "\\" ~ "$")* ~ "$$" }

// ===== HORIZONTAL RULE =====
hr = { WHITESPACE* ~ (hr_dash | hr_star | hr_underscore) ~ WHITESPACE* ~ (NEWLINE | EOI) }
hr_dash = { "-" ~ (WHITESPACE* ~ "-") ~ (WHITESPACE* ~ "-")+ }  // Exactly 3+ dashes with optional spaces
hr_star = { "*" ~ (WHITESPACE* ~ "*") ~ (WHITESPACE* ~ "*")+ }  // Exactly 3+ stars with optional spaces  
hr_underscore = { "_" ~ (WHITESPACE* ~ "_") ~ (WHITESPACE* ~ "_")+ }  // Exactly 3+ underscores with optional spaces

// ===== FOOTNOTES =====
// Inline footnote (Pandoc/Obsidian style): ^[text]
inline_footnote_ref = { "^" ~ "[" ~ (!"]" ~ ANY)+ ~ "]" }

// Footnote reference: [^label]
footnote_label = @{ (ASCII_ALPHANUMERIC | unicode_letter)+ }
footnote_ref   =  { "[^" ~ footnote_label ~ "]" }

// Footnote definition: [^label]: content
footnote_def = { "[^" ~ footnote_label ~ "]" ~ ":" ~ WHITESPACE+ ~ (!NEWLINE ~ ANY)* ~ (NEWLINE ~ WHITESPACE+ ~ (!NEWLINE ~ ANY)*)* }

// ===== COMMENTS =====
inline_comment = _{ "<!--" ~ (!"-->" ~ ANY)* ~ "-->" }
block_comment  = _{ "<!--" ~ (!"-->" ~ ANY)* ~ "-->" }

// ===== HTML =====
inline_html = { "<" ~ (!">" ~ ANY)+ ~ ">" }
block_html  = { "<" ~ (!">" ~ ANY | NEWLINE)* ~ ">" }

// ===== LISTS =====
list              =  { unordered_list | ordered_list }
unordered_list    =  { unordered_list_item ~ (NEWLINE ~ unordered_list_item)* ~ NEWLINE? }
ordered_list      =  { ordered_list_item ~ (NEWLINE ~ ordered_list_item)* ~ NEWLINE? }

// List items with specific marker types
unordered_list_item =  { (SOI | NEWLINE)? ~ INDENT_OPT? ~ (unordered_task_list_item | unordered_regular_list_item) }
ordered_list_item   =  { (SOI | NEWLINE)? ~ INDENT_OPT? ~ (ordered_task_list_item | ordered_regular_list_item) }

// Regular list items with specific markers
unordered_regular_list_item = ${ unordered_marker ~ " " ~ !task_marker ~ list_item_content }
ordered_regular_list_item   = ${ ordered_marker ~ " " ~ !task_marker ~ list_item_content }

// Task list items with specific markers  
unordered_task_list_item =  { unordered_marker ~ WHITESPACE* ~ task_marker ~ WHITESPACE* ~ list_item_content ~ task_metadata? }
ordered_task_list_item   =  { ordered_marker ~ WHITESPACE* ~ task_marker ~ WHITESPACE* ~ list_item_content ~ task_metadata? }

list_item_content =  { (!NEWLINE ~ ANY)+ }
unordered_marker  = @{ "-" | "*" | "+" }
ordered_marker    = @{ "-"? ~ ASCII_DIGIT+ ~ "." }

// Task-specific components
task_marker   = { "[" ~ (" " | "x" | "X") ~ "]" }
task_metadata = { "(" ~ (!":" ~ ANY)+ ~ ":" ~ " " ~ (!")" ~ ANY)+ ~ ")" }

// Inline task item (without bullet) - for use in paragraphs
inline_task_item = { task_marker ~ " " ~ inline* ~ task_metadata? }

// ===== DEFINITION LIST =====
def_list  =  { (term_line ~ (NEWLINE ~ def_line)+)+ }
term_line = @{ (!NEWLINE ~ ANY)+ }
def_line  =  { ":" ~ " " ~ (!NEWLINE ~ ANY)+ }

// ===== TABLES =====
table               =  { table_with_header | table_without_header }
table_with_header   =  { table_header ~ NEWLINE ~ table_sep ~ (NEWLINE ~ table_row)* }
table_without_header=  { table_sep ~ (NEWLINE ~ table_row)* }
table_header        =  { "|" ~ table_cell ~ ("|" ~ table_cell)* ~ "|"? }
table_sep           =  { "|" ~ table_sep_cell ~ ("|" ~ table_sep_cell)* ~ "|"? }
table_row           =  { "|" ~ table_cell ~ ("|" ~ table_cell)* ~ "|"? }
table_cell          =  { WHITESPACE* ~ table_cell_content* ~ WHITESPACE* }
table_cell_content  =  { escaped_char | inline_link | inline_image | code_inline | math_inline | emphasis | strikethrough | highlight | superscript | subscript | emoji | inline_html | footnote_ref | macro_inline | table_safe_text }
table_safe_text     = @{ (!"|" ~ !NEWLINE ~ ANY)+ }
table_sep_cell      =  { WHITESPACE* ~ ":"? ~ "-"+ ~ ":"? ~ WHITESPACE* }

// ===== MARCO =====

// Full :::tab block with optional title, tabs inside, and ::: end
tab_block         = { tab_header ~ NEWLINE ~ tabs_content ~ tab_end }
// :::tab header line
tab_header        = { ":::" ~ KW_TAB ~ (" " | "\t")* ~ tab_title? }
tab_title         = @{ (!NEWLINE ~ ANY)+ }
// End marker
tab_end           = { ":::" }
// Inside the block: mix of plain lines (default tab) and tabs
tabs_content      = { (tab | tab_content_line)* }
// A single tab
tab               = { tab_line ~ tab_body }
// @tab with optional name
tab_line          = { "@" ~ KW_TAB ~ tab_name? ~ NEWLINE }
tab_line_start    = { "@" ~ KW_TAB } // used for lookahead in tab_body
tab_name          = @{ (" " | "\t")* ~ (!NEWLINE ~ ANY)+ }
// Tab body = all lines until next @tab or tab_end
tab_body          = { (!(tab_line_start | tab_end) ~ (!NEWLINE ~ ANY)* ~ NEWLINE )* }
// Plain lines before the first @tab or between tabs become default tab content
tab_content_line  = { !(tab_line_start | tab_end) ~ (!NEWLINE ~ ANY)* ~ NEWLINE }

// User mention
user_mention =  { "@" ~ username ~ "[" ~ platform ~ "]" ~ ("(" ~ display_name ~ ")")? }
username     = @{ (unicode_letter | "_" | "-")+ }
platform     = @{ (!"]" ~ ANY)+ }
display_name = @{ (!")" ~ ANY)+ }

// Admonition blocks
admonition_type  = { KW_NOTE | KW_TIP | KW_WARNING | KW_DANGER | KW_INFO }
admonition_open  = { ":::" ~ (WHITESPACE | NEWLINE)* ~ admonition_type ~ ("[" ~ (!"]" ~ ANY)* ~ "]")? }
admonition_emoji = { ":::" ~ "[" ~ (!"]" ~ ANY)+ ~ "]" ~ (!NEWLINE ~ ANY)* }
admonition_close = { ":::" }
// allow nested admonitions by accepting any content that is not the closing delimiter
// Admonition block with graceful recovery: allow nested admonitions and an
// unclosed variant which consumes until EOI to avoid hard failures on missing
// closing delimiter.
admo_nest = { admonition_block | (!admonition_close ~ ANY)+ }
// Admonition block accepts either a proper closing `:::` or EOI to recover from
// unclosed admonitions; `admo_nest` allows nested content.
admonition_block = { (admonition_open | admonition_emoji) ~ ((!admonition_close ~ ANY) | admo_nest)* ~ (admonition_close | &EOI) }

// Bookmark
bookmark = { "[" ~ KW_BOOKMARK ~ ":" ~ (!"]" ~ ANY)+ ~ "](" ~ local_path ~ ("=" ~ ASCII_DIGIT+)? ~ ")" }

// Page tags and document references
page_format = { ^"A4" | ^"US" | ASCII_DIGIT+ }
page_tag    = { "[" ~ KW_PAGE ~ "=" ~ page_format? ~ "]" }
doc_ref     = { "[" ~ "@" ~ KW_DOC ~ "]" ~ "(" ~ local_path ~ ")" }

// Table of contents
toc       = { "[" ~ KW_TOC ~ toc_depth? ~ "]" ~ toc_doc? }
toc_depth = { "=" ~ ("1" | "2" | "3" | "4") }
toc_doc   = { "(" ~ "@" ~ KW_DOC ~ ")" }

// Run commands
script_type = { KW_BASH | KW_ZSH | KW_SH | KW_BAT | KW_POWERSHELL | KW_PS | KW_PYTHON | KW_PY }

run_inline       = { KW_RUN ~ script_type ~ "(" ~ (("\\" ~ ANY) | (!")" ~ ANY))* ~ ")" }
run_block_fenced = { "```" ~ KW_RUN ~ script_type ~ NEWLINE ~ (!"```" ~ ANY)* ~ "```" }

// Diagram blocks
diagram_type   = { KW_MERMAID | KW_GRAPHVIZ }
diagram_fenced = { "```" ~ diagram_type ~ NEWLINE ~ (!"```" ~ ANY)* ~ "```" }
