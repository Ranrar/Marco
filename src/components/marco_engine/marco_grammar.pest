// Marco flavor grammar
// This file defines the Marco markdown dialect used by the editor and parser.
// Covered features: link handling (validation, YouTube embedding, image.
// list parsing (ordered, unordered, nested, task lists), macros (inline and block),
// tables, headings, paragraphs, code/maths blocks, and common inline formatting.

// WHITESPACE is special in Pest - it gets consumed automatically between tokens
// For indented code, we need to handle spaces explicitly with atomic rules

// Matches single space or tab character
// Examples: " ", "\t"
WHITESPACE = _{ " " | "\t" }

// Matches line endings (cross-platform support)
// Examples: "\n", "\r\n"
NEWLINE = _{ "\r\n" | "\n" }

// Optional indentation - any number of spaces or tabs
// Examples: "", "  ", "\t\t", " \t "
INDENT_OPT = _{ (" " | "\t")* }

// Empty line with optional leading whitespace
// Examples: "\n", "  \n", "\t\t\n"
BLANK_LINE = _{ (" " | "\t")* ~ NEWLINE }

// Exactly 4 spaces for indentation (CommonMark standard)
// Examples: "    " (4 spaces only)
INDENT_SPACES = @{ " " ~ " " ~ " " ~ " " }

// Single tab character for indentation
// Examples: "\t"
INDENT_TAB = @{ "\t" }

// One unit of indentation (either 4 spaces or 1 tab)
// Examples: "    ", "\t"
INDENT_UNIT = _{ INDENT_SPACES | INDENT_TAB }

// 0-3 spaces (not enough for indentation)
// Examples: "", " ", "  ", "   "
NON_INDENT = _{ " "{0, 3} }

// Admonition block types (case-insensitive matching)
// Examples: "note", "NOTE", "Note"
KW_NOTE    = @{ ^"note" }
KW_TIP     = @{ ^"tip" }
KW_WARNING = @{ ^"warning" }
KW_DANGER  = @{ ^"danger" }
KW_INFO    = @{ ^"info" }

// Marco extension keywords
// Examples: "bookmark", "BOOKMARK"
KW_BOOKMARK = @{ ^"bookmark" }
KW_PAGE     = @{ ^"page" }
KW_DOC      = @{ ^"doc" }
KW_TOC      = @{ ^"toc" }
KW_TAB      = @{ ^"tab" }

// Script types for executable code blocks
// Examples: "bash", "BASH", "python", "PYTHON"
KW_BASH       = @{ ^"bash" }
KW_ZSH        = @{ ^"zsh" }
KW_SH         = @{ ^"sh" }
KW_BAT        = @{ ^"bat" }
KW_POWERSHELL = @{ ^"powershell" }
KW_PS         = @{ ^"ps" }
KW_PYTHON     = @{ ^"python" }
KW_PY         = @{ ^"py" }
KW_RUN        = @{ ^"run@" }

// Diagram types for visual content
// Examples: "mermaid", "MERMAID", "graphviz"
KW_MERMAID  = @{ ^"mermaid" }
KW_GRAPHVIZ = @{ ^"graphviz" }

// Root rule - document contains blocks with flexible separation
// Examples: empty document, single heading, multiple paragraphs with code blocks
document = { (BLANK_LINE* ~ block ~ BLANK_LINE*)* }

// Block-level elements ordered by parsing priority (most specific first)
// Examples: code blocks, headings, paragraphs, lists, tables
block = { code_block | math_block | hr | heading | blockquote | table | list | macro_block | footnote_def | reference_definition | reference_link | reference_image | def_list | block_comment | block_html | task_block | paragraph | unknown_block }

// Error recovery for unrecognized block content
// Examples: "~~~invalid~~~", "<<weird syntax>>"
unknown_block = { (!NEWLINE ~ ANY)+ }

// Marco-specific block extensions
// Examples: admonitions, executable code, diagrams, bookmarks
macro_block = { admonition_block | run_block_fenced | diagram_fenced | bookmark | block_youtube | block_image | tab_block }

// Core inline elements ordered by parsing priority (HTML removed - all HTML is block-level)
// Examples: `code`, **bold**, [links](url), $math$, escaped chars
inline_core = { escaped_char | inline_link | inline_image | autolink | inline_footnote_ref | code_inline | math_inline | emphasis | strikethrough | highlight | superscript | subscript | emoji | inline_comment | footnote_ref | macro_inline | hard_line_break | soft_line_break | text }

// Escape sequences for markdown special characters
// Examples: "\*", "\\", "\[", "\]"
escaped_char = @{ "\\" ~ (markdown_special | "\\") }

// Hard line break - 2+ spaces or backslash before newline
// Examples: "text  \n", "text\\\n"
hard_line_break = @{ (" "{2, } | "\\") ~ NEWLINE }

// Soft line break - newline that doesn't start a new block
// Examples: "line1\nline2" (within same paragraph)
soft_line_break = @{ NEWLINE ~ &(!block_start ~ !EOI) }

// All inline elements including task items
// Examples: regular text, **bold**, [x] completed task
inline = { inline_core | inline_task_item }

// Marco-specific inline extensions
// Examples: @user[platform], [page=A4], [toc], [@doc](file)
macro_inline = { user_mention | run_inline | page_tag | toc | doc_ref }

// Combined emphasis rules for proper precedence
// Examples: ***bold italic***, **bold**, *italic*
emphasis = { bold_italic | bold | italic }

// Word definition with optional hyphens and apostrophes
// Examples: "hello", "don't", "well-known", "café"
word = @{ unicode_letter+ ~ (inner_char* ~ unicode_letter+)* }

// Characters allowed inside words
// Examples: "don't" (apostrophe), "well-known" (hyphen)
inner_char = _{ "-" | "'" }

// Letters including Unicode characters
// Examples: "a", "A", "ñ", "中", "🙂"
unicode_letter = _{ ASCII_ALPHANUMERIC | LETTER }

// Safe punctuation that doesn't interfere with markdown
// Examples: ".", ",", "!", "?" (but not "*", "_", "`", etc.)
safe_punct = @{ !(markdown_special) ~ PUNCTUATION }

// Special characters reserved for markdown syntax
// Examples: "*", "_", "`", "#", "[", "]"
markdown_special = _{ "*" | "_" | "`" | "#" | "[" | "]" | "~" | ">" | "|" | "$" | "@" | "^" | "=" | "-" | "\\" }

// Mathematical symbols and operators
// Examples: "±", "√", "∞", "≈", "π", "α"
math_symbol = @{ "±" | "√" | "∞" | "∑" | "≈" | "≠" | "≤" | "≥" | "∆" | "π" | "α" | "β" | "γ" | "λ" | "μ" | "σ" | "Ω" | "+" | "=" | "×" | "÷" }

// text matching with block boundary detection
// Avoids consuming text that should be parsed as block elements
// Examples: "This is text", "Some *emphasis* here", but not "# Heading" or "```code"
text = {
    // More permissive text rule: Only refuse block markers that have proper syntax.
    // Allow content that starts with formatting markers (* _ ` etc.) since these
    // should be handled by formatting rules or serve as fallback content.
    (WHITESPACE+ ~ &(NEWLINE | EOI))
  | NEWLINE+ // Special case: just newlines

  | // Special case: whitespace-only lines
  ((SOI | NEWLINE) ~ WHITESPACE* ~ !(("#"{1, 6} ~ " ") | // ATX heading (must have space after #)
  ("***" | "---" | "___") ~ (WHITESPACE | NEWLINE | EOI) | // horizontal rule
  ">" ~ (" " | "\t" | &NEWLINE | &EOI) | // blockquote - enhanced detection
  ":::" | // admonition
  "```" ~ (WHITESPACE | NEWLINE | ASCII_ALPHA) | // fenced code block (must have space, newline, or language)
  INDENT_UNIT | // indented code
  (ASCII_DIGIT+ ~ "." ~ " ") | // ordered list
  (("-" | "*" | "+") ~ " ") | // unordered list (note: single * without space is not a list)
  "|" | // table row
  ("<" ~ ASCII_ALPHA ~ ASCII_ALPHANUMERIC* ~ (WHITESPACE | ">")) // html block tags (not inline tags)
  ) ~ text_no_formatting+)
  | start_line_formatting // Handle line-start formatting chars as text fallback

  | text_no_formatting+
}

// Handle formatting characters at line start that should be treated as text
// Examples: "*not bold", "_not italic" (when not properly formatted)
// Only matches single characters at line start, not multi-line content
start_line_formatting = @{ (SOI | NEWLINE) ~ WHITESPACE* ~ !("```" | "~~~") ~ formatting_char ~ (!NEWLINE ~ !("[" | "(") ~ text_content_chars)* }

// Characters that can start formatting but might be literal text
// Examples: "*", "_", "`", "~", "=" (exclude "!" since it's only used for images)
formatting_char = { "*" | "_" | "`" | "~" | "=" | "^" | "#" | "$" }

// Text content components for building text rules
// Examples: words, punctuation, spaces, math symbols
text_content_chars = { word | safe_punct | !((" "{2, } | "\\") ~ NEWLINE) ~ (" " | "\t") | math_symbol | inline_formatting_safe | ("`" ~ !"`") | "*" | "_" | "=" | "^" | "#" | "!" | "$" }

// More restrictive text content that stops at formatting boundaries
// Examples: plain text that doesn't cross `code`, **bold**, or $math$ boundaries
text_no_formatting = _{
    !("`" ~ (!"`" ~ ANY)+ ~ "`") ~  // Don't match across inline code
  !((" "{2, } | "\\") ~ NEWLINE) ~  // Don't match hard line breaks
  !NEWLINE ~  // Don't match soft line breaks
  !"[" ~  // Stop at potential links
  ( // Allow spaces before formatting markers but don't include the markers themselves
  (" " ~ !(("**" | "__" | "*" ~ !"*" | "$" | "["))) | // Regular content
  (word | safe_punct | "\t" | math_symbol | inline_formatting_safe))
}

// Block start detection for avoiding text conflicts
// Examples: "# heading", "> quote", "- list", "```code"
line_start_marker = _{ (heading_start | hr_start | list_start | blockquote_start | admonition_start | code_start | table_start | html_start) }

// Heading marker - 1-6 hashes followed by space
// Examples: "# ", "## ", "### "
heading_start = _{ "#"{1, 6} ~ " " }

// Horizontal rule marker - 3+ dashes, stars, or underscores
// Examples: "***", "---", "___"
hr_start = _{ ("***" | "---" | "___") ~ (WHITESPACE | NEWLINE | EOI) }

// List marker - dash/star/plus or numbered list with space
// Examples: "- ", "* ", "+ ", "1. ", "42. "
list_start = _{ NON_INDENT? ~ (("-" | "*" | "+") ~ " " | (ASCII_DIGIT+ ~ "." ~ " ")) }

// Blockquote marker - > with optional space/tab or at line end
// Examples: "> ", ">\t", ">\n"
blockquote_start = _{ ">" ~ (" " | "\t" | &NEWLINE | &EOI) }

// Admonition marker - triple colons
// Examples: ":::"
admonition_start = _{ ":::" }

// Code block markers - fenced or indented
// Examples: "```", "    " (4 spaces), "\t"
code_start = _{ "```" | INDENT_UNIT }

// HTML block start - opening tag
// Examples: "<div", "<p", "<h1"
html_start = _{ "<" ~ ASCII_ALPHA }

// Table marker - pipe character
// Examples: "|"
table_start = _{ "|" }

// Characters safe for inline formatting detection
// Examples: letters, numbers, some punctuation (excludes markdown specials)
inline_formatting_safe = _{ !("**" | "__" | "*" | "_" | "```" | "!" | "$$" | "$" | "~" | "\\" | "|") ~ ANY }

// URL-safe characters for link parsing
// Examples: "a-z", "0-9", "-", "_", ".", "/", "?", "&", "="
URL_SAFE = _{ unicode_letter | ASCII_DIGIT | "-" | "_" | "." | "/" | "?" | "&" | "=" | "%" | "#" | "~" | ":" }

// Single line of paragraph content (inline elements)
// Examples: "This is **bold** text", "Link: [example](url)"
paragraph_line = { inline_no_newline+ }

// Inline elements that don't include newlines (HTML removed - all HTML is block-level)
// Examples: **bold**, [links](url), `code`, but stops at line boundaries
inline_no_newline = { escaped_char | inline_link | inline_image | autolink | inline_footnote_ref | code_inline | math_inline | emphasis | strikethrough | highlight | superscript | subscript | emoji | inline_comment | footnote_ref | macro_inline | hard_line_break | text_no_newline }

// Text that stops at newlines and block boundaries
// Examples: "regular text", "some words", but not "# heading" at line start
text_no_newline = {
    // Allow whitespace but not newlines, and stop at block markers at line start
    (WHITESPACE+ ~ &(NEWLINE | EOI))
  | // Handle line-start with negative lookahead for block markers (but don't consume the newline)
  (SOI ~ WHITESPACE* ~ !(("#"{1, 6} ~ " ") | // ATX heading
  ("***" | "---" | "___") ~ (WHITESPACE | NEWLINE | EOI) | // horizontal rule
  ">" ~ (" " | "\t" | &NEWLINE | &EOI) | // blockquote
  ":::" | // admonition
  "```" ~ (WHITESPACE | NEWLINE | ASCII_ALPHA) | // fenced code
  INDENT_UNIT | // indented code
  (ASCII_DIGIT+ ~ "." ~ " ") | // ordered list
  (("-" | "*" | "+") ~ " ") | // unordered list
  "|" | // table row
  ("<" ~ ASCII_ALPHA ~ ASCII_ALPHANUMERIC* ~ (WHITESPACE | ">")) // html block tags
  ) ~ text_no_formatting+)
  | start_line_formatting // Handle line-start formatting chars as text fallback

  | text_no_formatting+
}

// Single-line paragraph (Marco extension: each line is a separate paragraph)
// Examples: "Line 1" (creates one paragraph), "Line 1\nLine 2" (creates two paragraphs)
paragraph = { NON_INDENT? ~ !(line_start_marker) ~ paragraph_line }

// Helper for detecting block start markers
// Examples: start of input/line followed by "# ", "```", "> ", etc.
block_start = _{ (SOI | NEWLINE) ~ WHITESPACE* ~ line_start_marker }

// ATX headings (##) and Setext headings (underlines)
// Allow 0-3 spaces of indentation before heading markers (CommonMark spec)

// ATX headings - hash markers followed by content
// Examples: "# Title", "## Section", "### Subsection"
H1 = { NON_INDENT? ~ "#" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H2 = { NON_INDENT? ~ "##" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H3 = { NON_INDENT? ~ "###" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H4 = { NON_INDENT? ~ "####" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H5 = { NON_INDENT? ~ "#####" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }
H6 = { NON_INDENT? ~ "######" ~ " "* ~ heading_content ~ (NEWLINE | EOI) }

// Setext headings - text followed by underline
// Examples: "Title\n====" (H1), "Section\n----" (H2)
setext_h1 = { NON_INDENT? ~ setext_content ~ NEWLINE ~ NON_INDENT? ~ "="+ ~ (WHITESPACE* ~ (NEWLINE | EOI)) }
setext_h2 = { NON_INDENT? ~ setext_content ~ NEWLINE ~ NON_INDENT? ~ "-"+ ~ (WHITESPACE* ~ (NEWLINE | EOI)) }

// Content for setext headings (single line)
// Examples: "Main Title", "Section Header"
setext_content = { (!NEWLINE ~ ANY)+ }

// Heading content for ATX headings - inline elements until line end
// Examples: "**Bold** Title", "Title with `code`"
heading_content = { heading_text+ }

// Individual text elements within headings
// Examples: words, formatting, links (but no newlines)
heading_text = { !(NEWLINE | EOI) ~ inline_core }

// Main heading rule - order by specificity (H6 first to avoid conflicts)
// Examples: "# Title", "## Section", "Title\n====="
heading = { H6 | H5 | H4 | H3 | H2 | H1 | setext_h2 | setext_h1 }

// Blockquote content line without the > marker (content after > and optional space)
// Examples: "Quote text", "**Bold** quote", "Quote with [link](url)"
blockquote_content = { (!NEWLINE ~ ANY)* }

// Single line of blockquote with > prefix stripped from content
// Examples: "> Quote text" -> content is "Quote text"
blockquote_line = { ">" ~ " "? ~ blockquote_content }

// Multi-line blockquote block - consecutive lines starting with >
// Examples: "> Line 1\n> Line 2", "> Single line"
blockquote = { blockquote_line ~ (NEWLINE ~ blockquote_line)* }

// Bold formatting with double asterisks or underscores
// Examples: "**bold text**", "__also bold__"
bold_asterisk   = { "**" ~ (!"**" ~ (!NEWLINE ~ ANY))+ ~ ("**" | &(NEWLINE | EOI)) }
bold_underscore = { "__" ~ (!"__" ~ (!NEWLINE ~ ANY))+ ~ ("__" | &(NEWLINE | EOI)) }
bold            = { bold_asterisk | bold_underscore }

// Italic formatting with single asterisks or underscores
// Examples: "*italic text*", "_also italic_"
italic_asterisk   = { "*" ~ !"*" ~ (!"*" ~ (!NEWLINE ~ ANY))+ ~ ("*" | &(NEWLINE | EOI)) }
italic_underscore = { "_" ~ !"_" ~ (!"_" ~ (!NEWLINE ~ ANY))+ ~ ("_" | &(NEWLINE | EOI)) }
italic            = { italic_asterisk | italic_underscore }

// Bold + Italic combinations with various markers
// Examples: "***bold italic***", "**_mixed_**", "__*mixed*__"
bold_italic_triple_asterisk   = { "***" ~ (!"***" ~ (!NEWLINE ~ ANY))+ ~ "***" }
bold_italic_triple_underscore = { "___" ~ (!"___" ~ (!NEWLINE ~ ANY))+ ~ "___" }
bold_italic_mixed_ast_under   = { "**_" ~ (!"_**" ~ (!NEWLINE ~ ANY))+ ~ "_**" }
bold_italic_mixed_under_ast   = { "__*" ~ (!"*__" ~ (!NEWLINE ~ ANY))+ ~ "*__" }
bold_italic_triple_mixed_au   = { "***" ~ (!"___" ~ (!NEWLINE ~ ANY))+ ~ "___" }
bold_italic_triple_mixed_ua   = { "___" ~ (!"***" ~ (!NEWLINE ~ ANY))+ ~ "***" }
bold_italic                   = { bold_italic_triple_asterisk | bold_italic_triple_underscore | bold_italic_mixed_ast_under | bold_italic_mixed_under_ast | bold_italic_triple_mixed_au | bold_italic_triple_mixed_ua }

// Strikethrough with tildes or dashes
// Examples: "~~deleted text~~", "--also deleted--"
strikethrough_tilde = @{ "~~" ~ (!"~~" ~ (!NEWLINE ~ ANY))+ ~ "~~" }
strikethrough_dash  = @{ "--" ~ (!"--" ~ (!NEWLINE ~ ANY))+ ~ "--" }
strikethrough       =  { strikethrough_tilde | strikethrough_dash }

// Highlight formatting (Marco extension)
// Examples: "==highlighted text=="
highlight = @{ "==" ~ (!"==" ~ (!NEWLINE ~ ANY))+ ~ "==" }

// Various inline formatting elements
// Examples: ":emoji:", `inline code`, ^superscript^, ˅subscript˅
emoji       = @{ ":" ~ (!(":" | WHITESPACE | NEWLINE) ~ ANY)+ ~ ":" }
code_inline = @{ "`" ~ (!"`" ~ ANY)+ ~ "`" }
superscript = @{ "^" ~ (!"^" ~ (!WHITESPACE ~ ANY))+ ~ "^" }

// Subscript with two styles - arrow or tilde (avoiding ~~ conflict)
// Examples: "˅subscript˅", "~sub~" (but not "~~strike~~")
subscript_arrow = @{ "˅" ~ (!"˅" ~ (!WHITESPACE ~ ANY))+ ~ "˅" }
subscript_tilde = @{ "~" ~ !"~" ~ (!"~" ~ (!WHITESPACE ~ ANY))+ ~ "~" }
subscript       =  { subscript_arrow | subscript_tilde }

// HTTP/HTTPS URLs and www domains
// Examples: "https://example.com", "http://site.org", "www.example.com"
http_url = @{ (("https://" | "http://") ~ URL_SAFE+) | ("www." ~ URL_SAFE+) }
www_url  = @{ "www." ~ URL_SAFE+ }

// Email address components for mailto links
// Examples: "user@domain.com", "test.email+tag@sub.example.org"
EMAIL_LOCAL       = @{ ASCII_ALPHANUMERIC+ ~ (ASCII_ALPHANUMERIC | "." | "_" | "-" | "+")* }
EMAIL_FULL_DOMAIN = @{ (ASCII_ALPHANUMERIC+ ~ ".")+ ~ ASCII_ALPHANUMERIC+ }
mailto            = @{ "mailto:" ~ EMAIL_LOCAL ~ "@" ~ EMAIL_FULL_DOMAIN }

// Local file paths - relative, absolute, and Windows drive paths
// Examples: "./file.txt", "../dir/file", "/absolute/path", "C:\Windows\file", "C:/Windows/file"
// "./My Folder/file.txt", "C:\Program Files\app.exe" (spaces allowed in local paths)
local_path = @{
    // Windows drive paths (both separators) - must come first to avoid conflicts
    (ASCII_ALPHA ~ (":\\" | ":/")) ~ (!")" ~ !"|" ~ ANY)+
  | // Unix absolute paths
  "/" ~ (!")" ~ !"|" ~ ANY)+
  | // Relative paths
  (("./" | "../")) ~ (!")" ~ !"|" ~ ANY)+
  | // Simple relative paths (no prefix)
  ASCII_ALPHANUMERIC+ ~ ("/" ~ (!")" ~ !"|" ~ ANY)+)+
}

// YouTube video URLs (both short and full formats)
// Examples: "https://youtu.be/dQw4w9WgXcQ", "https://www.youtube.com/watch?v=dQw4w9WgXcQ"
youtube_url = @{ ("https://youtu.be/" | "http://youtu.be/" | "https://www.youtube.com/watch?v=" | "http://www.youtube.com/watch?v=") ~ URL_SAFE+ }

// Image file extensions (case-insensitive)
// Examples: ".jpg", ".PNG", ".gif", ".WebP"
image_ext = @{ "." ~ (^"jpg" | ^"jpeg" | ^"png" | ^"gif" | ^"webp" | ^"svg") }

// Image URLs combining URL patterns with image extensions
// Examples: "https://example.com/image.png", "./local/image.jpg"
image_url = @{ (http_url | www_url | local_path) ~ image_ext }

// General link URL matcher for all link types
// Examples: "https://site.com", "mailto:user@domain.com", "./file.txt"
link_url = @{
    http_url
  | www_url
  | mailto
  | local_path
  | // Conservative fallback - stop at spaces, quotes, and closing parens
  (!(")" | WHITESPACE | "\"" | "'") ~ (ASCII_ALPHANUMERIC | unicode_letter | "-" | "_" | "." | "/" | "?" | "&" | "=" | "%" | "#" | "~" | ":"))+
}

// Link text with support for escaped brackets and nesting
// Examples: "link text", "text with \[brackets\]", "[nested [brackets]]"
inline_link_text  = @{ (escaped_bracket | balanced_brackets | (!"](" ~ !"]" ~ ANY))* }
escaped_bracket   =  { "\\" ~ ("[" | "]") }
balanced_brackets =  { "[" ~ (escaped_bracket | (!"]" ~ !"[" ~ ANY))* ~ "]" }

// Link titles in quotes
// Examples: "Link Title", 'Alternative Title'
link_title = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" | "'" ~ (!"'" ~ ANY)* ~ "'" }

// Standard markdown link syntax with optional titles
// Examples: "[text](url)", "[text](url "title")"
bracket_link_with_title    = @{ "[" ~ inline_link_text ~ "](" ~ link_url ~ WHITESPACE+ ~ link_title ~ ")" }
bracket_link_without_title = @{ "[" ~ inline_link_text ~ "](" ~ link_url ~ ")" }

// Autolinks in angle brackets
// Examples: "<https://example.com>", "<user@domain.com>"
autolink_email = { "<" ~ EMAIL_LOCAL ~ "@" ~ EMAIL_FULL_DOMAIN ~ ">" }
autolink_url   = { "<" ~ link_url ~ ">" }
autolink       = { autolink_email | autolink_url }

// Main link and image rules (order matters for specificity)
// Examples: "[text](url)", "![alt](image.jpg)", "<https://auto.link>"
inline_link  = { bracket_link_with_title | bracket_link_without_title | autolink }
inline_image = { "!" ~ "[" ~ inline_link_text ~ "](" ~ link_url ~ (WHITESPACE+ ~ link_title)? ~ ")" }

// Reference-style links and images
// Examples: "[link text][ref]", "![image][ref]"
block_caption   = { (!"]" ~ ANY)+ }
reference_link  = { "[" ~ block_caption ~ "]" ~ "[" ~ block_caption ~ "]" }
reference_image = { "!" ~ "[" ~ block_caption ~ "]" ~ "[" ~ block_caption ~ "]" }

// Reference definitions
// Examples: "[ref]: https://example.com", "[ref]: url "title""
ref_title            = { "\"" ~ (!"\"" ~ ANY)* ~ "\"" | "'" ~ (!"'" ~ ANY)* ~ "'" }
reference_definition = { "[" ~ block_caption ~ "]" ~ ":" ~ WHITESPACE* ~ inline_link ~ (WHITESPACE+ ~ ref_title)? ~ (NEWLINE | EOI) }

// Block-level images and YouTube embeds
// Examples: "![Large Image](image.png)", "[Video Title](https://youtu.be/id)"
block_image   = { "!"? ~ "[" ~ block_caption ~ "](" ~ image_url ~ ")" }
block_youtube = { "[" ~ block_caption ~ "](" ~ youtube_url ~ ")" }

// Variable-length fenced code blocks supporting nested code blocks (max 3 levels)
// Following CommonMark spec: closing fence must be at least as long as opening fence
language_id = @{ ASCII_ALPHA+ ~ (ASCII_ALPHANUMERIC | "-" | "_")* }

// Backtick fences of varying lengths (3 levels maximum)
// Note: Numbers refer to actual backtick count (3, 4, 5), not nesting level
// This follows CommonMark standard where fenced code blocks start at 3 backticks minimum
// Nesting: Level 1 = 3 backticks, Level 2 = 4 backticks, Level 3 = 5 backticks
fence_3 = @{ "```" }
fence_4 = @{ "````" }
fence_5 = @{ "`````" }

// Opening fence captures the exact length and optional language
// Examples: ```rust, ````markdown, `````html
fenced_code_open_3 = { fence_3 ~ language_id? ~ (WHITESPACE* ~ (NEWLINE | EOI)) }
fenced_code_open_4 = { fence_4 ~ language_id? ~ (WHITESPACE* ~ (NEWLINE | EOI)) }
fenced_code_open_5 = { fence_5 ~ language_id? ~ (WHITESPACE* ~ (NEWLINE | EOI)) }

// Closing fences must be at least as long as opening fence (CommonMark requirement)
// Level 1 (3 backticks) can be closed by 3, 4, or 5 backticks
// Level 2 (4 backticks) can be closed by 4 or 5 backticks
// Level 3 (5 backticks) can only be closed by 5 backticks
fenced_code_close_3 = { fence_3 | fence_4 | fence_5 }
fenced_code_close_4 = { fence_4 | fence_5 }
fenced_code_close_5 = { fence_5 }

// Content between fences - stops at appropriate closing fence for proper nesting
// Example: Level 1 stops at any fence ≥3, Level 2 stops at fence ≥4, etc.
fenced_code_content_3 = { (!fenced_code_close_3 ~ ANY)* }
fenced_code_content_4 = { (!fenced_code_close_4 ~ ANY)* }
fenced_code_content_5 = { (!fenced_code_close_5 ~ ANY)* }

// Complete fenced code blocks for each length with error recovery
// Example usage: ```js → Level 1, ````md → Level 2, `````html → Level 3
fenced_code_3 = { fenced_code_open_3 ~ fenced_code_content_3 ~ (fenced_code_close_3 | &EOI) }
fenced_code_4 = { fenced_code_open_4 ~ fenced_code_content_4 ~ (fenced_code_close_4 | &EOI) }
fenced_code_5 = { fenced_code_open_5 ~ fenced_code_content_5 ~ (fenced_code_close_5 | &EOI) }

// Main fenced code rule - order matters: longer fences first to prevent shorter ones from consuming them
fenced_code = { fenced_code_5 | fenced_code_4 | fenced_code_3 }

// Example of nested code blocks:
// `````documentation
// Here's a markdown example:
// 
// ````markdown
// # Title
// ```rust
// fn main() {
// println!("Hello!");
// }
// ```
// ````
// 
// End of documentation.
// `````

// Indented code blocks (4 spaces or 1 tab minimum)
// Examples: "    code line 1\n    code line 2", "\tfunction() {\n\t    return true;\n\t}"
indented_code = @{ INDENT_UNIT+ ~ (!NEWLINE ~ ANY)+ ~ (NEWLINE ~ INDENT_UNIT+ ~ (!NEWLINE ~ ANY)+)* }

// Main code block rule - fenced or indented
// Examples: "```js\ncode\n```", "    indented code"
code_block = { fenced_code | indented_code }

// Inline math with single dollar signs
// Examples: "$x^2 + y^2 = z^2$", "$\sum_{i=1}^{n} x_i$"
math_inline = { "$" ~ (!"$" ~ ANY | "\\" ~ "$")* ~ "$" }

// Block math with double dollar signs
// Examples: "$$\int_0^1 x^2 dx$$", "$$\begin{matrix}a & b\\c & d\end{matrix}$$"
math_block = { "$$" ~ (!"$$" ~ ANY | "\\" ~ "$")* ~ "$$" }

// Horizontal rule with various characters (3+ with optional spacing)
// Examples: "---", "***", "___", "- - -", "* * *"
hr      = { WHITESPACE* ~ (hr_dash | hr_star | hr_underscore) ~ WHITESPACE* ~ (NEWLINE | EOI) }
hr_dash = { "-" ~ (WHITESPACE* ~ "-") ~ (WHITESPACE* ~ "-")+ }
// Exactly 3+ dashes with optional spaces
hr_star = { "*" ~ (WHITESPACE* ~ "*") ~ (WHITESPACE* ~ "*")+ }
// Exactly 3+ stars with optional spaces
hr_underscore = { "_" ~ (WHITESPACE* ~ "_") ~ (WHITESPACE* ~ "_")+ }
// Exactly 3+ underscores with optional spaces

// Inline footnote with content in brackets (Pandoc/Obsidian style)
// Examples: "^[This is an inline footnote]", "^[See reference for details]"
inline_footnote_ref = { "^" ~ "[" ~ (!"]" ~ ANY)+ ~ "]" }

// Footnote reference label (alphanumeric and Unicode letters)
// Examples: "ref1", "note", "参考", "المرجع"
footnote_label = @{ (ASCII_ALPHANUMERIC | unicode_letter)+ }

// Footnote reference marker
// Examples: "[^ref1]", "[^note]", "[^参考]"
footnote_ref = { "[^" ~ footnote_label ~ "]" }

// Footnote definition with content (can be multi-line)
// Examples: "[^ref]: This is a footnote", "[^note]: Multi-line\n    footnote content"
footnote_def = { "[^" ~ footnote_label ~ "]" ~ ":" ~ WHITESPACE+ ~ (!NEWLINE ~ ANY)* ~ (NEWLINE ~ WHITESPACE+ ~ (!NEWLINE ~ ANY)*)* }

// HTML-style comments (inline and block versions)
// Examples: "<!-- inline comment -->", "<!-- multi-line\n     comment -->"
inline_comment = _{ "<!--" ~ (!"-->" ~ ANY)* ~ "-->" }
block_comment  = _{ "<!--" ~ (!"-->" ~ ANY)* ~ "-->" }

// HTML elements - all HTML is treated as block-level content
// Simple greedy approach: match everything from < until we find a paragraph break or EOF
// Examples: "<em>emphasis</em>", "<a href='...'><p>nested content</p></a>", "<img src='...' />"
block_html = { "<" ~ (!(NEWLINE ~ NEWLINE | EOI) ~ ANY)* }

// Main list types - unordered or ordered
// Examples: "- item 1", "1. first item", "* bullet", "+ another bullet"
list = { unordered_list | ordered_list }

// Multi-line unordered list with optional final newline
// Examples: "- item\n- item\n", "* bullet\n+ different bullet"
unordered_list = { unordered_list_item ~ (NEWLINE ~ unordered_list_item)* ~ NEWLINE? }

// Multi-line ordered list with optional final newline
// Examples: "1. first\n2. second\n", "1. item\n1. same number"
ordered_list = { ordered_list_item ~ (NEWLINE ~ ordered_list_item)* ~ NEWLINE? }

// List items with optional indentation and task/regular variants
// Examples: "- regular item", "  - indented", "- [x] completed task"
unordered_list_item = { (SOI | NEWLINE)? ~ INDENT_OPT? ~ (unordered_task_list_item | unordered_regular_list_item) }
ordered_list_item   = { (SOI | NEWLINE)? ~ INDENT_OPT? ~ (ordered_task_list_item | ordered_regular_list_item) }

// Regular list items without task markers
// Examples: "- regular item", "1. numbered item", "+ bullet item"
unordered_regular_list_item = ${ unordered_marker ~ " " ~ !task_marker ~ list_item_content }
ordered_regular_list_item   = ${ ordered_marker ~ " " ~ !task_marker ~ list_item_content }

// Task list items with checkboxes
// Examples: "- [ ] todo", "1. [x] done", "* [X] completed (user: 2024-01-15)"
unordered_task_list_item = { unordered_marker ~ WHITESPACE* ~ task_marker ~ WHITESPACE* ~ list_item_content ~ task_metadata? }
ordered_task_list_item   = { ordered_marker ~ WHITESPACE* ~ task_marker ~ WHITESPACE* ~ list_item_content ~ task_metadata? }

// Content of list item (everything after marker and space)
// Examples: "item text", "**bold** item", "item with [link](url)"
list_item_content = { (!NEWLINE ~ ANY)+ }

// List markers for different list types
// Examples: "-", "*", "+", "1.", "42.", "-1."
unordered_marker = @{ "-" | "*" | "+" }
ordered_marker   = @{ "-"? ~ ASCII_DIGIT+ ~ "." }

// Task list components
// Examples: "[ ]" (empty), "[x]" (done), "[X]" (done caps)
task_marker = @{ "[" ~ (" " | "x" | "X") ~ "]" }

// Optional task metadata with user and date
// Examples: "(user: 2024-01-15)", "(alice: completed task)"
task_metadata = { "(" ~ (!":" ~ ANY)+ ~ ":" ~ " " ~ (!")" ~ ANY)+ ~ ")" }

// Inline task item without list marker (for use in paragraphs)
// Examples: "[x] completed inline task", "[ ] todo (user: 2024-01-15)"
inline_task_item = { task_marker ~ " " ~ inline* ~ task_metadata? }

// Block-level task item without list marker (standalone task)
// Examples: "[x] Completed task", "[ ] Todo task", "[ ] Task with (user: 2024-01-15)"
task_block = { task_marker ~ WHITESPACE* ~ (!NEWLINE ~ ANY)* ~ task_metadata? }

// Definition list with terms and definitions
// Examples: "Term 1\n: definition 1\n: definition 2\nTerm 2\n: definition"
def_list = { (term_line ~ (NEWLINE ~ def_line)+)+ }

// Term line (the thing being defined)
// Examples: "HTML", "Markdown", "Definition term"
term_line = @{ (!NEWLINE ~ ANY)+ }

// Definition line starting with colon and space
// Examples: ": A markup language", ": Used for formatting text"
def_line = { ":" ~ " " ~ (!NEWLINE ~ ANY)+ }

// Table with or without header row
// Examples: header tables, separator-only tables
table = { table_with_header | table_without_header }

// Table with header row followed by separator
// Examples: "| Head 1 | Head 2 |\n|--------|--------|\n| Cell 1 | Cell 2 |"
table_with_header = { table_header ~ NEWLINE ~ table_sep ~ (NEWLINE ~ table_row)* }

// Table starting with separator row (no header)
// Examples: "|--------|--------|\n| Cell 1 | Cell 2 |"
table_without_header = { table_sep ~ (NEWLINE ~ table_row)* }

// Table components with optional trailing pipe
// Examples: "| Header 1 | Header 2 |", "| Header 1 | Header 2"
table_header = { "|" ~ table_cell ~ ("|" ~ table_cell)* ~ "|"? }
table_sep    = { "|" ~ table_sep_cell ~ ("|" ~ table_sep_cell)* ~ "|"? }
table_row    = { "|" ~ table_cell ~ ("|" ~ table_cell)* ~ "|"? }

// Table cell with optional whitespace padding
// Examples: " Cell content ", "**Bold** cell", " `code` cell "
table_cell = { WHITESPACE* ~ table_cell_content* ~ WHITESPACE* }

// Content allowed in table cells (no pipes or newlines, HTML removed - use inline code for HTML in tables)
// Examples: "text", "**bold**", "[link](url)", "`code`", "`<span>html</span>`"
table_cell_content = { escaped_char | inline_link | inline_image | code_inline | math_inline | emphasis | strikethrough | highlight | superscript | subscript | emoji | footnote_ref | macro_inline | table_safe_text }

// Text safe for table cells (excludes pipes and newlines)
// Examples: "regular text", "no | pipes", "no newlines"
table_safe_text = @{ (!"|" ~ !NEWLINE ~ ANY)+ }

// Table separator cell with alignment markers
// Examples: "---", ":---", "---:", ":---:"
table_sep_cell = { WHITESPACE* ~ ":"? ~ "-"+ ~ ":"? ~ WHITESPACE* }

// Tab block container with header, content, and closing
// Examples: ":::tab\n@tab Tab1\ncontent\n@tab Tab2\nmore\n:::"
tab_block = { tab_header ~ NEWLINE ~ tabs_content ~ tab_end }

// Tab block header with optional title
// Examples: ":::tab", ":::tab Main Tabs", ":::tab   Settings"
tab_header = { ":::" ~ KW_TAB ~ (" " | "\t")* ~ tab_title? }

// Optional title for the tab block
// Examples: "Main Navigation", "Code Examples", "Settings Panel"
tab_title = @{ (!NEWLINE ~ ANY)+ }

// Tab block closing marker
// Examples: ":::"
tab_end = { ":::" }

// Content inside tab block (mix of tabs and default content)
// Examples: tab definitions, plain lines, mixed content
tabs_content = { (tab | tab_content_line)* }

// Individual tab with name and content
// Examples: "@tab JavaScript\ncode here", "@tab Python\nmore code"
tab = { tab_line ~ tab_body }

// Tab definition line with optional name
// Examples: "@tab", "@tab JavaScript", "@tab   Settings Tab"
tab_line = { "@" ~ KW_TAB ~ tab_name? ~ NEWLINE }

// Tab line start marker for lookahead
// Examples: "@tab"
tab_line_start = { "@" ~ KW_TAB }

// Optional tab name with whitespace
// Examples: " JavaScript", "   Settings Tab", " Main Content"
tab_name = @{ (" " | "\t")* ~ (!NEWLINE ~ ANY)+ }

// Tab content until next tab or end marker
// Examples: "function() {\n  return true;\n}", "Content lines\nMore content"
tab_body = { (!(tab_line_start | tab_end) ~ (!NEWLINE ~ ANY)* ~ NEWLINE)* }
// Plain lines that become default tab content
// Examples: "Default content", "Lines before first @tab"
tab_content_line = { !(tab_line_start | tab_end) ~ (!NEWLINE ~ ANY)* ~ NEWLINE }

// User mention with platform and optional display name
// Examples: "@john[twitter]", "@alice[github](Alice Smith)"
user_mention = { "@" ~ username ~ "[" ~ platform ~ "]" ~ ("(" ~ display_name ~ ")")? }

// Username for mentions (letters, underscores, hyphens)
// Examples: "john_doe", "alice-smith", "user123"
username = @{ (unicode_letter | "_" | "-")+ }

// Platform identifier in brackets
// Examples: "twitter", "github", "linkedin", "discord"
platform = @{ (!"]" ~ ANY)+ }

// Optional display name in parentheses
// Examples: "John Doe", "Alice Smith", "Real Name"
display_name = @{ (!")" ~ ANY)+ }

// Admonition block types and structure
// Examples: ":::note", ":::warning", ":::tip[Custom Title]"
admonition_type = { KW_NOTE | KW_TIP | KW_WARNING | KW_DANGER | KW_INFO }

// Admonition opening with type and optional title
// Examples: ":::note", ":::warning[Important]", ":::tip [Helpful Hint]"
admonition_open = { ":::" ~ (WHITESPACE | NEWLINE)* ~ admonition_type ~ ("[" ~ (!"]" ~ ANY)* ~ "]")? }

// Emoji-style admonition with custom icon
// Examples: ":::[🔥] Custom warning", ":::[✨] Special note"
admonition_emoji = { ":::" ~ "[" ~ (!"]" ~ ANY)+ ~ "]" ~ (!NEWLINE ~ ANY)* }

// Admonition closing marker
// Examples: ":::"
admonition_close = { ":::" }

// Nested admonition content (allows nesting and error recovery)
// Examples: nested admonitions, text content, other markdown
admo_nest = { admonition_block | (!admonition_close ~ ANY)+ }

// Complete admonition block with error recovery for unclosed blocks
// Examples: ":::note\nContent\n:::", ":::tip\nUnclosed content"
admonition_block = { (admonition_open | admonition_emoji) ~ ((!admonition_close ~ ANY) | admo_nest)* ~ (admonition_close | &EOI) }

// Bookmark reference with optional line number
// Examples: "[bookmark: Section 1](./doc.md)", "[bookmark: Code](file.rs=42)"
bookmark = { "[" ~ KW_BOOKMARK ~ ":" ~ (!"]" ~ ANY)+ ~ "](" ~ local_path ~ ("=" ~ ASCII_DIGIT+)? ~ ")" }

// Page format specifications
// Examples: "A4", "US", "210", "11"
page_format = { ^"A4" | ^"US" | ASCII_DIGIT+ }

// Page tag for document formatting
// Examples: "[page=A4]", "[page=US]", "[page=210]"
page_tag = { "[" ~ KW_PAGE ~ "=" ~ page_format? ~ "]" }

// Document reference link
// Examples: "[@doc](./other.md)", "[@doc](../docs/api.md)"
doc_ref = { "[" ~ "@" ~ KW_DOC ~ "]" ~ "(" ~ local_path ~ ")" }

// Table of contents with optional depth and document reference
// Examples: "[toc]", "[toc=3]", "[toc=2](@doc)"
toc = { "[" ~ KW_TOC ~ toc_depth? ~ "]" ~ toc_doc? }

// TOC depth limit (1-4 heading levels)
// Examples: "=1", "=2", "=3", "=4"
toc_depth = { "=" ~ ("1" | "2" | "3" | "4") }

// TOC for external document
// Examples: "(@doc)"
toc_doc = { "(" ~ "@" ~ KW_DOC ~ ")" }

// Supported script types for executable code
// Examples: "bash", "python", "powershell", "zsh"
script_type = { KW_BASH | KW_ZSH | KW_SH | KW_BAT | KW_POWERSHELL | KW_PS | KW_PYTHON | KW_PY }

// Inline executable code
// Examples: "run@bash(ls -la)", "run@python(print('hello'))"
run_inline = { KW_RUN ~ script_type ~ "(" ~ (("\\" ~ ANY) | (!")" ~ ANY))* ~ ")" }

// Fenced executable code block
// Examples: "```run@bash\nls -la\necho done\n```"
run_block_fenced = { "```" ~ KW_RUN ~ script_type ~ NEWLINE ~ (!"```" ~ ANY)* ~ "```" }

// Supported diagram types
// Examples: "mermaid", "graphviz"
diagram_type = { KW_MERMAID | KW_GRAPHVIZ }

// Fenced diagram block
// Examples: "```mermaid\ngraph TD\n  A --> B\n```", "```graphviz\ndigraph G { A -> B }\n```"
diagram_fenced = { "```" ~ diagram_type ~ NEWLINE ~ (!"```" ~ ANY)* ~ "```" }
