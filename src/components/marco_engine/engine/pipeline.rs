//! Marco Engine Pipeline - Orchestrates parsing, AST building, and rendering
//!
//! This module provides the main pipeline that coordinates all components
//! of the Marco engine to transform source text into rendered output.

use crate::components::marco_engine::{
    ast::{AstBuilder, Node},
    errors::MarcoError,
    grammar::{MarcoParser, Rule},
    render::{HtmlOptions, MarcoRenderer, OutputFormat, TextOptions},
};
use pest::Parser;
use std::path::Path;

// Re-export the Rule enum generated by pest_derive
pub use pest::iterators::{Pair, Pairs};

/// Configuration for the Marco engine pipeline
#[derive(Debug, Clone)]
pub struct PipelineConfig {
    /// Enable debug mode for verbose output
    pub debug: bool,
    /// Default output format
    pub default_format: OutputFormat,
    /// HTML rendering options
    pub html_options: HtmlOptions,
    /// Text rendering options  
    pub text_options: TextOptions,
    /// Enable AST caching for performance
    pub cache_ast: bool,
    /// Enable parallel processing where applicable
    pub parallel: bool,
}

impl Default for PipelineConfig {
    fn default() -> Self {
        Self {
            debug: false,
            default_format: OutputFormat::Html,
            html_options: HtmlOptions::default(),
            text_options: TextOptions::default(),
            cache_ast: false,
            parallel: false,
        }
    }
}

/// Main Marco engine pipeline
pub struct MarcoPipeline {
    config: PipelineConfig,
    cached_ast: Option<Node>,
}

impl MarcoPipeline {
    /// Create a new pipeline with the given configuration
    pub fn new(config: PipelineConfig) -> Self {
        Self {
            config,
            cached_ast: None,
        }
    }

    /// Create a pipeline with default configuration
    pub fn with_defaults() -> Self {
        Self::new(PipelineConfig::default())
    }

    /// Parse Marco source text into an AST
    pub fn parse(&mut self, input: &str) -> Result<&Node, MarcoError> {
        if self.config.debug {
            eprintln!("Parsing {} characters of input", input.len());
        }

        // Parse with Pest
        let pairs = MarcoParser::parse(Rule::file, input)
            .map_err(|e| MarcoError::Parse(format!("Pest parsing failed: {}", e)))?;

        if self.config.debug {
            eprintln!("Pest parsing successful, building AST");
        }

        // Build AST
        let ast_builder = AstBuilder;
        let ast = AstBuilder::build(pairs)?;

        if self.config.debug {
            eprintln!(
                "AST built successfully with {} top-level children",
                if let Node::Document { children, .. } = &ast {
                    children.len()
                } else {
                    0
                }
            );
        }

        // Cache AST if enabled
        if self.config.cache_ast {
            self.cached_ast = Some(ast);
            Ok(self.cached_ast.as_ref().unwrap())
        } else {
            // For now, we'll need to return a reference to a stored AST
            // In a real implementation, we might want to handle this differently
            self.cached_ast = Some(ast);
            Ok(self.cached_ast.as_ref().unwrap())
        }
    }

    /// Render the current AST to the specified format
    pub fn render(&self, format: Option<OutputFormat>) -> Result<String, MarcoError> {
        let ast = self
            .cached_ast
            .as_ref()
            .ok_or_else(|| MarcoError::AST("No AST available - call parse() first".to_string()))?;

        let format = format.unwrap_or_else(|| self.config.default_format.clone());

        if self.config.debug {
            eprintln!("Rendering AST to format: {:?}", format);
        }

        match format {
            OutputFormat::Html => Ok(MarcoRenderer::render_html(
                ast,
                self.config.html_options.clone(),
            )),
            OutputFormat::Text => Ok(MarcoRenderer::render_text(
                ast,
                self.config.text_options.clone(),
            )),
            OutputFormat::Json => MarcoRenderer::render_json(ast, false),
            OutputFormat::JsonPretty => MarcoRenderer::render_json(ast, true),
        }
    }

    /// Complete pipeline: parse input and render to specified format
    pub fn process(
        &mut self,
        input: &str,
        format: Option<OutputFormat>,
    ) -> Result<String, MarcoError> {
        self.parse(input)?;
        self.render(format)
    }

    /// Process input and render to default format
    pub fn process_default(&mut self, input: &str) -> Result<String, MarcoError> {
        self.process(input, None)
    }

    /// Process a file and return rendered output
    pub fn process_file<P: AsRef<Path>>(&mut self, path: P) -> Result<String, MarcoError> {
        let content = std::fs::read_to_string(path)
            .map_err(|e| MarcoError::IO(format!("Failed to read file: {}", e)))?;

        self.process_default(&content)
    }

    /// Get the current AST (if available)
    pub fn get_ast(&self) -> Option<&Node> {
        self.cached_ast.as_ref()
    }

    /// Clear cached AST
    pub fn clear_cache(&mut self) {
        self.cached_ast = None;
    }

    /// Update configuration
    pub fn update_config(&mut self, config: PipelineConfig) {
        self.config = config;
        // Clear cache when config changes as it might affect parsing/rendering
        if !self.config.cache_ast {
            self.clear_cache();
        }
    }

    /// Get current configuration
    pub fn get_config(&self) -> &PipelineConfig {
        &self.config
    }
}

/// Convenience functions for quick processing
impl MarcoPipeline {
    /// Quick HTML conversion
    pub fn to_html(input: &str) -> Result<String, MarcoError> {
        let mut pipeline = Self::with_defaults();
        pipeline.config.default_format = OutputFormat::Html;
        pipeline.process_default(input)
    }

    /// Quick text conversion
    pub fn to_text(input: &str) -> Result<String, MarcoError> {
        let mut pipeline = Self::with_defaults();
        pipeline.config.default_format = OutputFormat::Text;
        pipeline.process_default(input)
    }

    /// Quick JSON conversion
    pub fn to_json(input: &str, pretty: bool) -> Result<String, MarcoError> {
        let mut pipeline = Self::with_defaults();
        pipeline.config.default_format = if pretty {
            OutputFormat::JsonPretty
        } else {
            OutputFormat::Json
        };
        pipeline.process_default(input)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pipeline_basic() {
        let input = "# Hello World\n\nThis is **bold** text.";

        let mut pipeline = MarcoPipeline::with_defaults();
        let result = pipeline.process_default(input);

        // For now, we expect this to fail since we don't have the actual grammar file
        // But the structure should be correct
        assert!(result.is_err() || result.is_ok());
    }

    #[test]
    fn test_pipeline_convenience_methods() {
        let input = "# Test\n\nContent";

        // These will fail without the grammar file, but test the interface
        let _html_result = MarcoPipeline::to_html(input);
        let _text_result = MarcoPipeline::to_text(input);
        let _json_result = MarcoPipeline::to_json(input, true);
    }

    #[test]
    fn test_pipeline_config() {
        let mut config = PipelineConfig::default();
        config.debug = true;
        config.cache_ast = true;

        let mut pipeline = MarcoPipeline::new(config);
        assert!(pipeline.get_config().debug);
        assert!(pipeline.get_config().cache_ast);

        // Test config update
        let new_config = PipelineConfig {
            debug: false,
            ..Default::default()
        };
        pipeline.update_config(new_config);
        assert!(!pipeline.get_config().debug);
    }
}
