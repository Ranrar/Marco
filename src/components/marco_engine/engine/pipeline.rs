//! Marco Engine Pipeline - Orchestrates parsing, AST building, and rendering
//!
//! This module provides the main pipeline that coordinates all components
//! of the Marco engine to transform source text into rendered output.

use crate::components::marco_engine::{
    ast::{AstBuilder, Node},
    errors::MarcoError,
    grammar::{MarcoParser, Rule},
    parser::{EnhancedMarcoParser, ParserConfig},
    render::{HtmlOptions, MarcoRenderer, OutputFormat, TextOptions},
};
use pest::Parser;
use std::path::Path;

// Re-export the Rule enum generated by pest_derive
pub use pest::iterators::{Pair, Pairs};

/// Configuration for the Marco engine pipeline
#[derive(Debug, Clone)]
pub struct PipelineConfig {
    /// Enable debug mode for verbose output
    pub debug: bool,
    /// Default output format
    pub default_format: OutputFormat,
    /// HTML rendering options
    pub html_options: HtmlOptions,
    /// Text rendering options  
    pub text_options: TextOptions,
    /// Enable AST caching for performance
    pub cache_ast: bool,
    /// Enable parallel processing where applicable
    pub parallel: bool,
    /// Enhanced parser configuration
    pub parser_config: ParserConfig,
}

impl Default for PipelineConfig {
    fn default() -> Self {
        Self {
            debug: false,
            default_format: OutputFormat::Html,
            html_options: HtmlOptions::default(),
            text_options: TextOptions::default(),
            cache_ast: false,
            parallel: false,
            parser_config: ParserConfig::default(),
        }
    }
}

/// Main Marco engine pipeline
pub struct MarcoPipeline {
    config: PipelineConfig,
    cached_ast: Option<Node>,
    parser: EnhancedMarcoParser,
}

impl MarcoPipeline {
    /// Create a new pipeline with the given configuration
    pub fn new(config: PipelineConfig) -> Self {
        let parser = EnhancedMarcoParser::with_config(config.parser_config.clone());
        Self {
            config,
            cached_ast: None,
            parser,
        }
    }

    /// Create a pipeline with default configuration
    pub fn with_defaults() -> Self {
        Self::new(PipelineConfig::default())
    }

    /// Parse Marco source text into an AST
    pub fn parse(&mut self, input: &str) -> Result<&Node, MarcoError> {
        if self.config.debug {
            eprintln!("Parsing {} characters of input", input.len());
        }

        // Use enhanced parser for better error handling and features
        let parse_result = self.parser.parse_document(input);
        
        if self.config.debug {
            eprintln!("Parse result: {:?}", parse_result.stats);
            if !parse_result.warnings.is_empty() {
                eprintln!("Parse warnings: {:?}", parse_result.warnings);
            }
        }

        // Convert parse nodes to pest pairs for AST building
        let pairs = match parse_result.nodes {
            Ok(nodes) => {
                // For now, fall back to direct pest parsing for AST building
                // TODO: Convert ParseNode tree to AST directly
                MarcoParser::parse(Rule::file, input)
                    .map_err(|e| MarcoError::Parse(format!("Pest parsing failed: {}", e)))?
            }
            Err(e) => return Err(e),
        };

        if self.config.debug {
            eprintln!("Pest parsing successful, building AST");
        }

        // Build AST
        let ast_builder = AstBuilder;
        let ast = AstBuilder::build(pairs)?;

        if self.config.debug {
            eprintln!(
                "AST built successfully with {} top-level children",
                if let Node::Document { children, .. } = &ast {
                    children.len()
                } else {
                    0
                }
            );
        }

        // Cache AST if enabled
        if self.config.cache_ast {
            self.cached_ast = Some(ast);
            Ok(self.cached_ast.as_ref().unwrap())
        } else {
            // For now, we'll need to return a reference to a stored AST
            // In a real implementation, we might want to handle this differently
            self.cached_ast = Some(ast);
            Ok(self.cached_ast.as_ref().unwrap())
        }
    }

    /// Render the current AST to the specified format
    pub fn render(&self, format: Option<OutputFormat>) -> Result<String, MarcoError> {
        let ast = self
            .cached_ast
            .as_ref()
            .ok_or_else(|| MarcoError::AST("No AST available - call parse() first".to_string()))?;

        let format = format.unwrap_or_else(|| self.config.default_format.clone());

        if self.config.debug {
            eprintln!("Rendering AST to format: {:?}", format);
        }

        match format {
            OutputFormat::Html => Ok(MarcoRenderer::render_html(
                ast,
                self.config.html_options.clone(),
            )),
            OutputFormat::Text => Ok(MarcoRenderer::render_text(
                ast,
                self.config.text_options.clone(),
            )),
            OutputFormat::Json => MarcoRenderer::render_json(ast, false),
            OutputFormat::JsonPretty => MarcoRenderer::render_json(ast, true),
        }
    }

    /// Complete pipeline: parse input and render to specified format
    pub fn process(
        &mut self,
        input: &str,
        format: Option<OutputFormat>,
    ) -> Result<String, MarcoError> {
        self.parse(input)?;
        self.render(format)
    }

    /// Process input and render to default format
    pub fn process_default(&mut self, input: &str) -> Result<String, MarcoError> {
        self.process(input, None)
    }

    /// Process a file and return rendered output
    pub fn process_file<P: AsRef<Path>>(&mut self, path: P) -> Result<String, MarcoError> {
        let content = std::fs::read_to_string(path)
            .map_err(|e| MarcoError::IO(format!("Failed to read file: {}", e)))?;

        self.process_default(&content)
    }

    /// Get the current AST (if available)
    pub fn get_ast(&self) -> Option<&Node> {
        self.cached_ast.as_ref()
    }

    /// Clear cached AST
    pub fn clear_cache(&mut self) {
        self.cached_ast = None;
    }

    /// Update configuration
    pub fn update_config(&mut self, config: PipelineConfig) {
        // Update parser configuration if it changed
        self.parser = EnhancedMarcoParser::with_config(config.parser_config.clone());
        self.config = config;
        // Clear cache when config changes as it might affect parsing/rendering
        if !self.config.cache_ast {
            self.clear_cache();
        }
    }

    /// Get parser cache statistics
    pub fn parser_cache_stats(&self) -> crate::components::marco_engine::parser::CacheStats {
        self.parser.cache_stats()
    }

    /// Clear parser cache
    pub fn clear_parser_cache(&mut self) {
        self.parser.clear_cache();
    }

    /// Validate syntax without full parsing
    pub fn validate_syntax(&mut self, rule_name: &str, input: &str) -> Result<bool, MarcoError> {
        self.parser.validate(rule_name, input)
    }

    /// Analyze rule usage in document
    pub fn analyze_rule_usage(&mut self, input: &str) -> Result<crate::components::marco_engine::parser::RuleAnalysis, MarcoError> {
        self.parser.analyze_rule_usage(input)
    }

    /// Get current configuration
    pub fn get_config(&self) -> &PipelineConfig {
        &self.config
    }
}

/// Convenience functions for quick processing
impl MarcoPipeline {
    /// Quick HTML conversion
    pub fn to_html(input: &str) -> Result<String, MarcoError> {
        let mut pipeline = Self::with_defaults();
        pipeline.config.default_format = OutputFormat::Html;
        pipeline.process_default(input)
    }

    /// Quick text conversion
    pub fn to_text(input: &str) -> Result<String, MarcoError> {
        let mut pipeline = Self::with_defaults();
        pipeline.config.default_format = OutputFormat::Text;
        pipeline.process_default(input)
    }

    /// Quick JSON conversion
    pub fn to_json(input: &str, pretty: bool) -> Result<String, MarcoError> {
        let mut pipeline = Self::with_defaults();
        pipeline.config.default_format = if pretty {
            OutputFormat::JsonPretty
        } else {
            OutputFormat::Json
        };
        pipeline.process_default(input)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pipeline_basic() {
        let input = "# Hello World\n\nThis is **bold** text.";

        let mut pipeline = MarcoPipeline::with_defaults();
        let result = pipeline.process_default(input);

        // For now, we expect this to fail since we don't have the actual grammar file
        // But the structure should be correct
        assert!(result.is_err() || result.is_ok());
    }

    #[test]
    fn test_pipeline_convenience_methods() {
        let input = "# Test\n\nContent";

        // These will fail without the grammar file, but test the interface
        let _html_result = MarcoPipeline::to_html(input);
        let _text_result = MarcoPipeline::to_text(input);
        let _json_result = MarcoPipeline::to_json(input, true);
    }

    #[test]
    fn test_pipeline_config() {
        let mut config = PipelineConfig::default();
        config.debug = true;
        config.cache_ast = true;

        let mut pipeline = MarcoPipeline::new(config);
        assert!(pipeline.get_config().debug);
        assert!(pipeline.get_config().cache_ast);

        // Test config update
        let new_config = PipelineConfig {
            debug: false,
            ..Default::default()
        };
        pipeline.update_config(new_config);
        assert!(!pipeline.get_config().debug);
    }
}
