// build.rs: Generates one #[test] per CommonMark spec example
use std::fs;

use serde_json::Value;

fn main() {
    let spec_path = "tests/spec.json";
    let spec_json = fs::read_to_string(spec_path).expect("spec.json not found");
    let json: Value = serde_json::from_str(&spec_json).expect("Failed to parse spec.json");

    // Render-only CommonMark tests (excluding GFM and math)
    {
        let render_out_path = "tests/render_spec_tests.rs";
        let mut render_out = String::new();
        render_out.push_str("// This file is generated by build.rs\n");
        render_out.push_str("use marco::logic::core::inline::parser::parse_phrases;\n");
        render_out.push_str("use marco::logic::renderer::html_render::HtmlRenderer;\n");
        // Use HtmlRenderer::inline_node_to_inline directly
        render_out.push_str("#[cfg(test)]\nmod render_spec_generated {\n");
        render_out.push_str("    use super::*;\n");
        if let Some(arr) = json.as_array() {
            for (i, obj) in arr.iter().enumerate() {
                let markdown = obj.get("markdown").and_then(|v| v.as_str()).unwrap_or("");
                let html = obj.get("html").and_then(|v| v.as_str()).unwrap_or("");
                // Skip GFM and math examples by section name
                let section = obj.get("section").and_then(|v| v.as_str()).unwrap_or("");
                if section.contains("GFM") || section.contains("Math") || section.contains("math") {
                    continue;
                }
                render_out.push_str(&format!("    #[test]\n    fn render_example_{}() {{\n", i + 1));
                render_out.push_str(&format!("        let ast = parse_phrases(r#\"{}\"#);\n", markdown.replace("\"", "\\\"")));
                render_out.push_str("        let inlines: Vec<(marco::logic::ast::inlines::Inline, marco::logic::core::event_types::SourcePos)> = ast.iter().map(|n| HtmlRenderer::inline_node_to_inline(n)).collect();\n");
                render_out.push_str("        let rendered = HtmlRenderer::render_inlines(&inlines);\n");
                render_out.push_str(&format!("        assert_eq!(rendered.trim(), r###\"{}\"###.trim(), \"Render mismatch for example {}\");\n", html, i + 1));
                render_out.push_str("    }\n");
            }
        }
        render_out.push_str("}\n");
        fs::write(render_out_path, render_out).expect("Failed to write generated render test file");
    }

    // AST tests
    let mut ast_out = String::new();
    ast_out.push_str("// This file is generated by build.rs\n");
    ast_out.push_str("use marco::logic::core::inline::parser::parse_phrases;\n");
    ast_out.push_str("#[cfg(test)]\nmod ast_spec_generated {\n");
    ast_out.push_str("    use super::*;\n");
    if let Some(arr) = json.as_array() {
        for (i, obj) in arr.iter().enumerate() {
            let markdown = obj.get("markdown").and_then(|v| v.as_str()).unwrap_or("");
            ast_out.push_str(&format!("    #[test]\n    fn ast_example_{}() {{\n", i + 1));
            ast_out.push_str(&format!("        let ast = parse_phrases(r#\"{}\"#);\n", markdown.replace("\"", "\\\"")));
            ast_out.push_str(&format!("        assert!(!ast.is_empty(), \"ast_example_{} produced empty AST\");\n", i + 1));
            ast_out.push_str("    }\n");
        }
    }
    ast_out.push_str("}\n");
    fs::write("tests/ast_spec_tests.rs", ast_out).expect("Failed to write generated AST test file");

    // Parser tests
    let mut parser_out = String::new();
    parser_out.push_str("// This file is generated by build.rs\n");
    parser_out.push_str("use marco::logic::core::inline::parser::parse_phrases;\n");
    parser_out.push_str("use marco::logic::core::inline::types::InlineNode;\n");
    parser_out.push_str("#[cfg(test)]\nmod parser_spec_generated {\n");
    parser_out.push_str("    use super::*;\n");
    if let Some(arr) = json.as_array() {
        for (i, obj) in arr.iter().enumerate() {
            let markdown = obj.get("markdown").and_then(|v| v.as_str()).unwrap_or("");
            parser_out.push_str(&format!("    #[test]\n    fn parser_example_{}() {{\n", i + 1));
            parser_out.push_str(&format!("        let ast = parse_phrases(r#\"{}\"#);\n", markdown.replace("\"", "\\\"")));
            parser_out.push_str("        // Check for at least one non-text node\n");
            parser_out.push_str("        let valid = ast.iter().any(|n| match n {\n");
            parser_out.push_str("            InlineNode::Emphasis { .. } | InlineNode::Strong { .. } | InlineNode::Link { .. } | InlineNode::Image { .. } | InlineNode::Code { .. } | InlineNode::Math { .. } | InlineNode::Html { .. } | InlineNode::Entity { .. } | InlineNode::AttributeBlock { .. } | InlineNode::Strikethrough { .. } | InlineNode::TaskListItem { .. } => true,\n");
            parser_out.push_str("            _ => false,\n");
            parser_out.push_str("        });\n");
            parser_out.push_str(&format!("        assert!(valid, \"parser_example_{} did not produce valid node structure\");\n", i + 1));
            parser_out.push_str("    }\n");
        }
    }
    parser_out.push_str("}\n");
    fs::write("tests/parser_spec_tests.rs", parser_out).expect("Failed to write generated Parser test file");

    // Golden tests (existing)
    let out_path = "tests/commonmark_golden.rs";
    let mut out = String::new();
    out.push_str("// This file is generated by build.rs\n");
    out.push_str("use marco::logic::core::inline::parser::parse_phrases;\n");
    out.push_str("#[cfg(test)]\nmod golden_spec_generated {\n");
    out.push_str("    use super::*;\n");
    if let Some(arr) = json.as_array() {
        for (i, obj) in arr.iter().enumerate() {
            let markdown = obj.get("markdown").and_then(|v| v.as_str()).unwrap_or("");
            out.push_str(&format!("    #[test]\n    fn spec_example_{}() {{\n", i + 1));
            out.push_str(&format!("        let ast = parse_phrases(r#\"{}\"#);\n", markdown.replace("\"", "\\\"")));
            out.push_str(&format!("        let ast_str = format!(\"{{:?}}\", ast);\n"));
            out.push_str(&format!("        assert!(!ast_str.is_empty(), \"spec_example_{} produced empty AST\");\n", i + 1));
            out.push_str("    }\n");
        }
    }
    out.push_str("}\n");
    fs::write(out_path, out).expect("Failed to write generated test file");
}
