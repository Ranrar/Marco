// CommonMark Section 6 - Inline Content Parser
// 
// This file orchestrates all inline elements with proper precedence rules.
// 
// Precedence (highest to lowest):
// 1. Backslash escapes (highest - processed first)
// 2. Code spans (protect their content from further parsing)
// 3. Autolinks (processed before other inline elements)
// 4. HTML tags (raw HTML, no markdown processing inside)
// 5. Images (![ before links) - includes inline and reference images (Phase 7)
// 6. Links ([text](url)) - includes inline and reference links (Phase 7)
// 7. Line breaks (hard line breaks)
// 8. Strong emphasis (** or __)
// 9. Emphasis (* or _)
// 10. Plain text (lowest - fallback)
// 
// This ordering ensures that:
// - Escapes work everywhere (even in code spans conceptually, though code spans ignore them)
// - Code spans and autolinks protect their content from emphasis parsing
// - HTML attributes don't get markdown processing
// - Images tried before links (![ vs [)
// - Link brackets bind tighter than emphasis markers
// - Emphasis and strong can nest properly
// - Reference-style links/images tried before inline variants (within link/image rules)

// Main inline content rule - a sequence of inline elements
inline_content = {
    inline_element+
}

// Inline element dispatcher - tries each type in precedence order
// Made silent (_) to avoid extra nesting in parse tree
inline_element = _{
    escape // Highest: backslash escapes

  | code_span // Protects content from parsing

  | autolink // URIs and emails processed early

  | html_tag // Raw HTML tags

  | image // Images: ![alt][label], ![label][], ![label], ![alt](url) (Phase 7)

  | link // Links: [text][label], [label][], [label], [text](url) (Phase 7)

  | line_break // Hard line breaks (2+ spaces or backslash)

  | strong // ** or __ (before double emphasis)

  | emphasis // * or _ (after double emphasis)

  | entity_reference // Entity and numeric character references (Phase 4)

  | loose_angle_bracket // Literal < that's not valid HTML

  | text // Lowest: plain text fallback
}

// Loose angle bracket - literal < that doesn't form valid HTML
// Matches: <foo, <div id="bar, < followed by anything except valid HTML
// This prevents parse errors when < appears in text
loose_angle_bracket = @{
    "<"
}

// Plain text - any characters that aren't special inline markers  
// Stops at special characters that could start inline elements
// Special handling for underscores: consumes intraword underscores as literal text
text = ${
    (intraword_underscore | text_char)+
}

// Intraword underscore: word containing underscores (treated as literal)
// Matches: foo_bar, foo_bar_, foo_bar_baz_, пристаням_стремятся_
// Must contain at least one underscore mixed with alphanumeric chars (including Unicode)
// Uses LETTER and NUMBER for Unicode support (includes Cyrillic, etc.)
intraword_underscore = @{
    // Match any contiguous sequence of letters/numbers and underscores
    // that contains at least one of each
    ((LETTER | NUMBER)+ ~ UNDERSCORE ~ (LETTER | NUMBER | UNDERSCORE)*)
  | (UNDERSCORE ~ (LETTER | NUMBER) ~ (LETTER | NUMBER | UNDERSCORE)*)
}

text_char = {
    !(ASTERISK // Could start emphasis or strong
  | UNDERSCORE // Could start emphasis or strong
  | BACKTICK // Could start code span
  | BACKSLASH // Could start escape
  | "<" // Could start autolink or HTML tag
  | "[" // Could start link
  | "!" // Could start image (![)
  | "&" // Could start entity reference
  | " " ~ " " // Could start line break (2+ spaces)
  // NEWLINE removed - now handled by soft_line_break in line_break rule
  ) ~ ANY
}

// Note on delimiter runs and nesting:
// 
// The current implementation handles simple delimiter matching.
// For full CommonMark compliance with delimiter runs, we would need:
// 1. Left-flanking delimiter run detection
// 2. Right-flanking delimiter run detection
// 3. Can-open and can-close semantics
// 4. Proper nesting depth tracking
// 
// This is a complex state machine that may require:
// - Custom Rust code for delimiter run matching
// - Or PrattParser for operator precedence
// - Or manual AST post-processing
// 
// For now, we implement basic matching which handles most common cases.
// Full delimiter run semantics can be added in the AST builder phase.
